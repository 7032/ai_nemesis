<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VIPER GENESIS â€” A Tribute to Gradius</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#000;display:flex;align-items:center;justify-content:center;font-family:'Press Start 2P',monospace}
canvas{image-rendering:pixelated;image-rendering:crisp-edges;cursor:none}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
'use strict';

// ==================== CONFIGURATION ====================
const W = 480, H = 320;
const CONFIG = {
  PLAYER_START_X: 60, PLAYER_START_Y: 160,
  PLAYER_BASE_SPEED: 3.0, PLAYER_SPEED_INCREMENT: 1.0,
  PLAYER_MAX_SPEED_LEVEL: 5, PLAYER_SHOT_INTERVAL: 6,
  PLAYER_BULLET_SPEED: 10, PLAYER_HITBOX_W: 20, PLAYER_HITBOX_H: 10,
  PLAYER_INITIAL_LIVES: 3, PLAYER_MAX_LIVES: 9,
  OPTION_MAX: 4, OPTION_TRAIL_DELAY: 12, OPTION_RADIUS: 6,
  SHIELD_MAX_HP: 6,
  LASER_WIDTH_RATIO: 0.4, LASER_BEAM_HEIGHT: 4,
  MISSILE_SPEED: 3, MISSILE_GRAVITY: 0.12, MISSILE_GROUND_SPEED: 4,
  EXTEND_FIRST: 30000, EXTEND_EVERY: 100000,
  CRT_SCANLINE_OPACITY: 0.12, CRT_VIGNETTE_STRENGTH: 0.35,
  AUDIO_MASTER_VOLUME: 0.4, BGM_VOLUME: 0.3, SFX_VOLUME: 0.45
};

// ==================== CANVAS SETUP ====================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = W; canvas.height = H;

function resizeCanvas() {
  const ga = W / H, wa = innerWidth / innerHeight;
  let dw, dh;
  if (wa > ga) { dh = innerHeight; dw = dh * ga; }
  else { dw = innerWidth; dh = dw / ga; }
  canvas.style.width = dw + 'px'; canvas.style.height = dh + 'px';
}
resizeCanvas();
addEventListener('resize', resizeCanvas);

// ==================== AUDIO ENGINE ====================
class AudioEngine {
  constructor() {
    this.ctx = null; this.master = null; this.bgmGain = null; this.sfxGain = null;
    this.initialized = false; this.currentBGM = null; this.bgmNodes = [];
  }
  init() {
    if (this.initialized) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.master = this.ctx.createGain();
      this.master.gain.value = CONFIG.AUDIO_MASTER_VOLUME;
      this.master.connect(this.ctx.destination);
      this.bgmGain = this.ctx.createGain();
      this.bgmGain.gain.value = CONFIG.BGM_VOLUME;
      this.bgmGain.connect(this.master);
      this.sfxGain = this.ctx.createGain();
      this.sfxGain.gain.value = CONFIG.SFX_VOLUME;
      this.sfxGain.connect(this.master);
      this.initialized = true;
    } catch(e) { console.warn('Audio init failed:', e); }
  }
  playNote(freq, duration, type='square', dest=null, detune=0) {
    if (!this.initialized) return null;
    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type; osc.frequency.value = freq;
    if (detune) osc.detune.value = detune;
    gain.gain.setValueAtTime(0.3, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + duration);
    osc.connect(gain);
    gain.connect(dest || this.sfxGain);
    osc.start(t); osc.stop(t + duration);
    return osc;
  }
  playSE(name) {
    if (!this.initialized) return;
    const t = this.ctx.currentTime;
    switch(name) {
      case 'shot': {
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = 'square'; o.frequency.setValueAtTime(880, t);
        o.frequency.exponentialRampToValueAtTime(440, t+0.05);
        g.gain.setValueAtTime(0.15, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.06);
        o.connect(g); g.connect(this.sfxGain); o.start(t); o.stop(t+0.06);
        break;
      }
      case 'laser': {
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = 'sawtooth'; o.frequency.setValueAtTime(220, t);
        o.frequency.exponentialRampToValueAtTime(110, t+0.15);
        g.gain.setValueAtTime(0.12, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
        o.connect(g); g.connect(this.sfxGain); o.start(t); o.stop(t+0.2);
        break;
      }
      case 'missile': {
        const n = this.ctx.createBufferSource(), buf = this.ctx.createBuffer(1, this.ctx.sampleRate*0.1, this.ctx.sampleRate);
        const d = buf.getChannelData(0);
        for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.max(0,1-i/d.length);
        n.buffer = buf; const g = this.ctx.createGain();
        g.gain.setValueAtTime(0.12, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.1);
        n.connect(g); g.connect(this.sfxGain); n.start(t);
        break;
      }
      case 'enemyHit': {
        const n = this.ctx.createBufferSource(), buf = this.ctx.createBuffer(1, this.ctx.sampleRate*0.03, this.ctx.sampleRate);
        const d = buf.getChannelData(0);
        for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*0.5;
        n.buffer = buf; const g = this.ctx.createGain();
        g.gain.setValueAtTime(0.1, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.03);
        n.connect(g); g.connect(this.sfxGain); n.start(t);
        break;
      }
      case 'explodeSmall': {
        const n = this.ctx.createBufferSource(), buf = this.ctx.createBuffer(1, this.ctx.sampleRate*0.12, this.ctx.sampleRate);
        const d = buf.getChannelData(0);
        for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.max(0,1-i/d.length)*0.6;
        n.buffer = buf; const g = this.ctx.createGain();
        const o = this.ctx.createOscillator();
        o.type='sine'; o.frequency.setValueAtTime(300, t);
        o.frequency.exponentialRampToValueAtTime(80, t+0.1);
        const og = this.ctx.createGain();
        og.gain.setValueAtTime(0.1, t); og.gain.exponentialRampToValueAtTime(0.001, t+0.1);
        g.gain.setValueAtTime(0.15, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.12);
        n.connect(g); g.connect(this.sfxGain); o.connect(og); og.connect(this.sfxGain);
        n.start(t); o.start(t); o.stop(t+0.12);
        break;
      }
      case 'explodeBig': {
        const n = this.ctx.createBufferSource(), buf = this.ctx.createBuffer(1, this.ctx.sampleRate*0.4, this.ctx.sampleRate);
        const d = buf.getChannelData(0);
        for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.max(0,1-i/d.length);
        n.buffer = buf; const g = this.ctx.createGain();
        const o = this.ctx.createOscillator();
        o.type='sine'; o.frequency.setValueAtTime(200, t);
        o.frequency.exponentialRampToValueAtTime(25, t+0.3);
        const og = this.ctx.createGain();
        og.gain.setValueAtTime(0.15, t); og.gain.exponentialRampToValueAtTime(0.001, t+0.35);
        g.gain.setValueAtTime(0.2, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.4);
        n.connect(g); g.connect(this.sfxGain); o.connect(og); og.connect(this.sfxGain);
        n.start(t); o.start(t); o.stop(t+0.4);
        break;
      }
      case 'capsule': {
        [523,659,784,1047].forEach((f,i) => {
          const o = this.ctx.createOscillator(), g = this.ctx.createGain();
          o.type='sine'; o.frequency.value=f;
          g.gain.setValueAtTime(0, t+i*0.05);
          g.gain.linearRampToValueAtTime(0.12, t+i*0.05+0.01);
          g.gain.exponentialRampToValueAtTime(0.001, t+i*0.05+0.1);
          o.connect(g); g.connect(this.sfxGain); o.start(t+i*0.05); o.stop(t+i*0.05+0.12);
        });
        break;
      }
      case 'powerup': {
        [523,659,784,1047,1319].forEach((f,i) => {
          const o = this.ctx.createOscillator(), g = this.ctx.createGain();
          o.type='sine'; o.frequency.value=f;
          g.gain.setValueAtTime(0, t+i*0.06);
          g.gain.linearRampToValueAtTime(0.15, t+i*0.06+0.01);
          g.gain.exponentialRampToValueAtTime(0.001, t+i*0.06+0.15);
          o.connect(g); g.connect(this.sfxGain); o.start(t+i*0.06); o.stop(t+i*0.06+0.18);
        });
        break;
      }
      case 'playerDeath': {
        const n = this.ctx.createBufferSource(), buf = this.ctx.createBuffer(1, this.ctx.sampleRate*0.5, this.ctx.sampleRate);
        const d = buf.getChannelData(0);
        for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.max(0,1-i/d.length);
        n.buffer = buf; const g = this.ctx.createGain();
        g.gain.setValueAtTime(0.25, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.5);
        const o = this.ctx.createOscillator(), og = this.ctx.createGain();
        o.type='sine'; o.frequency.setValueAtTime(400, t);
        o.frequency.exponentialRampToValueAtTime(30, t+0.4);
        og.gain.setValueAtTime(0.2, t); og.gain.exponentialRampToValueAtTime(0.001, t+0.5);
        n.connect(g); g.connect(this.sfxGain); o.connect(og); og.connect(this.sfxGain);
        n.start(t); o.start(t); o.stop(t+0.5);
        break;
      }
      case 'warning': {
        for(let i=0;i<4;i++){
          const o = this.ctx.createOscillator(), g = this.ctx.createGain();
          o.type='square'; o.frequency.value=440;
          g.gain.setValueAtTime(0, t+i*0.3);
          g.gain.linearRampToValueAtTime(0.12, t+i*0.3+0.01);
          g.gain.setValueAtTime(0.12, t+i*0.3+0.12);
          g.gain.linearRampToValueAtTime(0, t+i*0.3+0.15);
          o.connect(g); g.connect(this.sfxGain); o.start(t+i*0.3); o.stop(t+i*0.3+0.15);
        }
        break;
      }
      case 'shieldHit': {
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type='sine'; o.frequency.setValueAtTime(1200, t);
        o.frequency.exponentialRampToValueAtTime(600, t+0.08);
        g.gain.setValueAtTime(0.1, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.08);
        o.connect(g); g.connect(this.sfxGain); o.start(t); o.stop(t+0.1);
        break;
      }
    }
  }
  stopBGM() {
    this.bgmNodes.forEach(n => { try { n.stop(); } catch(e){} });
    this.bgmNodes = []; this.currentBGM = null;
  }
  playBGM(name) {
    if (!this.initialized) return;
    this.stopBGM();
    this.currentBGM = name;
    this._loopBGM(name);
  }
  _loopBGM(name) {
    if (this.currentBGM !== name || !this.initialized) return;
    const t = this.ctx.currentTime;
    const bpm = {title:100, stage1:150, stage2:130, stage3:170, boss:160}[name] || 140;
    const beatDur = 60/bpm;
    const notes = this._getBGMNotes(name);
    let maxEnd = 0;
    notes.forEach(n => {
      const startT = t + n.time * beatDur;
      const dur = n.dur * beatDur;
      const endT = startT + dur;
      if (endT > maxEnd) maxEnd = endT;
      const osc = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      osc.type = n.wave || 'square';
      osc.frequency.value = n.freq;
      const vol = n.vol || 0.12;
      gain.gain.setValueAtTime(0, startT);
      gain.gain.linearRampToValueAtTime(vol, startT + 0.005);
      gain.gain.setValueAtTime(vol, endT - 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, endT);
      osc.connect(gain); gain.connect(this.bgmGain);
      osc.start(startT); osc.stop(endT + 0.01);
      this.bgmNodes.push(osc);
    });
    const loopDur = (maxEnd - t) * 1000;
    setTimeout(() => this._loopBGM(name), loopDur - 100);
  }
  _note(name) {
    const notes = {C:261.63,Cs:277.18,D:293.66,Ds:311.13,E:329.63,F:349.23,Fs:369.99,G:392,Gs:415.3,A:440,As:466.16,B:493.88};
    const match = name.match(/^([A-G]s?)(\d)$/);
    if (!match) return 440;
    const base = notes[match[1]];
    const oct = parseInt(match[2]) - 4;
    return base * Math.pow(2, oct);
  }
  _getBGMNotes(name) {
    const n = (note, time, dur, wave, vol) => ({freq:this._note(note), time, dur, wave: wave||'square', vol: vol||0.1});
    const bass = (note, time, dur) => n(note, time, dur, 'triangle', 0.08);
    switch(name) {
      case 'title': {
        const notes = [];
        const chords = [['C3','E3','G3'],['As2','D3','F3'],['Gs2','C3','Ds3'],['G2','B2','D3']];
        for(let bar=0;bar<2;bar++){
          chords.forEach((ch,ci) => {
            ch.forEach((note,ni) => {
              notes.push(n(note, bar*16+ci*4+ni*0.5, 1.5, 'triangle', 0.06));
              const hi = note.replace(/\d/,m=>parseInt(m)+2);
              notes.push(n(hi, bar*16+ci*4+ni*0.5+0.25, 0.8, 'sine', 0.05));
            });
          });
        }
        return notes;
      }
      case 'stage1': {
        const notes = [];
        const melody = ['A4','C5','E5','A5','G4','B4','D5','G5','F4','A4','C5','F5','E4','Gs4','B4','E5'];
        melody.forEach((note,i) => notes.push(n(note, i*0.75, 0.6, 'square', 0.1)));
        const melody2 = ['A5','E5','C5','A4','G5','D5','B4','G4','F5','C5','A4','F4','E5','B4','Gs4','E4'];
        melody2.forEach((note,i) => notes.push(n(note, 12+i*0.75, 0.6, 'square', 0.1)));
        const bassLine = ['A2','A2','G2','G2','F2','F2','E2','E2'];
        bassLine.forEach((note,i) => { for(let j=0;j<3;j++) notes.push(bass(note, i*3+j, 0.8)); });
        for(let i=0;i<24;i++){
          if(i%2===0) notes.push({freq:100,time:i,dur:0.1,wave:'sine',vol:0.08});
          if(i%2===1) notes.push({freq:200,time:i,dur:0.08,wave:'triangle',vol:0.05});
          notes.push({freq:8000,time:i+0.5,dur:0.05,wave:'square',vol:0.02});
        }
        return notes;
      }
      case 'stage2': {
        const notes = [];
        const arp = ['D4','F4','A4','D5','A4','F4','C4','E4','G4','C5','G4','E4',
                     'As3','D4','F4','As4','F4','D4','A3','Cs4','E4','A4','E4','Cs4'];
        arp.forEach((note,i) => notes.push(n(note, i*0.5, 0.4, 'triangle', 0.09)));
        ['D2','D2','C2','C2','As1','As1','A1','A1'].forEach((note,i) => {
          notes.push(bass(note, i*1.5, 1.4));
        });
        for(let i=0;i<12;i++){
          notes.push({freq:150,time:i,dur:0.08,wave:'sine',vol:0.06});
          if(i%3===2) notes.push({freq:300,time:i+0.5,dur:0.06,wave:'triangle',vol:0.04});
        }
        return notes;
      }
      case 'stage3': {
        const notes = [];
        const melody = ['E5','B4','E5','G5','D5','A4','D5','Fs5','C5','G4','C5','E5','B4','Fs4','B4','Ds5'];
        melody.forEach((note,i) => notes.push(n(note, i*0.5, 0.4, 'square', 0.1)));
        const bassNotes = ['E2','E3','E2','E3','D2','D3','D2','D3','C2','C3','C2','C3','B1','B2','B1','B2'];
        bassNotes.forEach((note,i) => notes.push(bass(note, i*0.5, 0.4)));
        for(let i=0;i<16;i++){
          notes.push({freq:80,time:i*0.5,dur:0.06,wave:'sine',vol:0.07});
          notes.push({freq:80,time:i*0.5+0.25,dur:0.06,wave:'sine',vol:0.05});
          if(i%2===1) notes.push({freq:250,time:i*0.5,dur:0.05,wave:'triangle',vol:0.04});
        }
        return notes;
      }
      case 'boss': {
        const notes = [];
        const melody = ['Cs4','E4','Gs4','Cs5','B4','Gs4','A3','Cs4','E4','A4','Gs4','E4',
                        'Fs3','A3','Cs4','Fs4','E4','Cs4','Gs3','B3','Ds4','Gs4','Fs4','Ds4'];
        melody.forEach((note,i) => notes.push(n(note, i*0.4, 0.35, 'square', 0.11)));
        for(let i=0;i<10;i++){
          notes.push(bass('Cs2', i*0.5, 0.15));
          notes.push(bass('Cs2', i*0.5+0.25, 0.15));
        }
        for(let i=0;i<20;i++){
          notes.push({freq:100,time:i*0.5,dur:0.06,wave:'sine',vol:0.08});
          notes.push({freq:200,time:i*0.5+0.25,dur:0.05,wave:'triangle',vol:0.05});
          if(i%2===0) notes.push({freq:6000,time:i*0.5+0.125,dur:0.03,wave:'square',vol:0.02});
        }
        return notes;
      }
      default: return [];
    }
  }
}
const audio = new AudioEngine();

// ==================== INPUT MANAGER ====================
const keys = {};
const prevKeys = {};
addEventListener('keydown', e => { keys[e.code] = true; if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault(); });
addEventListener('keyup', e => { keys[e.code] = false; });
function keyPressed(code) { return keys[code] && !prevKeys[code]; }
function keyHeld(code) { return !!keys[code]; }
function updatePrevKeys() { for(const k in keys) prevKeys[k] = keys[k]; }

function getInput() {
  const inp = { up:false, down:false, left:false, right:false, shot:false, missile:false, powerup:false, pause:false, start:false, fullscreen:false };
  inp.up = keyHeld('ArrowUp') || keyHeld('KeyW');
  inp.down = keyHeld('ArrowDown') || keyHeld('KeyS');
  inp.left = keyHeld('ArrowLeft') || keyHeld('KeyA');
  inp.right = keyHeld('ArrowRight') || keyHeld('KeyD');
  inp.shot = keyHeld('KeyZ') || keyHeld('Space');
  inp.missile = keyHeld('KeyX');
  inp.powerup = keyPressed('KeyC') || keyPressed('Enter');
  inp.pause = keyPressed('Escape');
  inp.start = keyPressed('Space') || keyPressed('KeyZ') || keyPressed('Enter');
  inp.fullscreen = keyPressed('KeyF');
  // Debug
  inp.debugToggle = keys['ShiftLeft'] && keyPressed('KeyD');
  inp.invincible = keys['ShiftLeft'] && keyPressed('KeyI');
  inp.allPowerUp = keys['ShiftLeft'] && keyPressed('KeyP');
  inp.nextStage = keys['ShiftLeft'] && keyPressed('KeyN');
  // Gamepad
  try {
    const gp = navigator.getGamepads()[0];
    if (gp) {
      const deadzone = 0.2;
      if (gp.axes[1] < -deadzone || (gp.buttons[12] && gp.buttons[12].pressed)) inp.up = true;
      if (gp.axes[1] > deadzone || (gp.buttons[13] && gp.buttons[13].pressed)) inp.down = true;
      if (gp.axes[0] < -deadzone || (gp.buttons[14] && gp.buttons[14].pressed)) inp.left = true;
      if (gp.axes[0] > deadzone || (gp.buttons[15] && gp.buttons[15].pressed)) inp.right = true;
      if (gp.buttons[0] && gp.buttons[0].pressed) inp.shot = true;
      if (gp.buttons[1] && gp.buttons[1].pressed) inp.missile = true;
      if (gp.buttons[2] && gp.buttons[2].pressed) inp.powerup = true;
      if (gp.buttons[9] && gp.buttons[9].pressed) inp.start = true;
    }
  } catch(e){}
  return inp;
}

// ==================== UTILITY FUNCTIONS ====================
function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }
function lerp(a, b, t) { return a + (b - a) * t; }
function dist(x1, y1, x2, y2) { return Math.sqrt((x2-x1)**2 + (y2-y1)**2); }
function angleTo(x1, y1, x2, y2) { return Math.atan2(y2-y1, x2-x1); }
function aabb(ax, ay, aw, ah, bx, by, bw, bh) {
  return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
}
function rnd(min, max) { return min + Math.random() * (max - min); }
function rndInt(min, max) { return Math.floor(rnd(min, max+1)); }

// ==================== PARTICLE SYSTEM ====================
const particles = [];
const MAX_PARTICLES = 300;

function spawnParticle(x, y, vx, vy, life, size, colors, gravity=0, friction=0.98, shape='circle') {
  if (particles.length >= MAX_PARTICLES) particles.shift();
  particles.push({ x, y, vx, vy, life, maxLife: life, size, colors, gravity, friction, shape,
    rotation: Math.random()*Math.PI*2, rotSpeed: (Math.random()-0.5)*0.3 });
}

function spawnExplosion(x, y, count=8, speed=3, life=15, size=3, colors=['#FFF','#FFA','#F80','#F40']) {
  for (let i = 0; i < count; i++) {
    const a = (Math.PI*2/count)*i + rnd(-0.3,0.3);
    const s = rnd(speed*0.5, speed);
    spawnParticle(x+rnd(-2,2), y+rnd(-2,2), Math.cos(a)*s, Math.sin(a)*s, life+rndInt(-3,3), rnd(size*0.5,size), colors, 0.02, 0.96);
  }
}

function spawnBigExplosion(x, y) {
  for(let w=0;w<3;w++){
    setTimeout(()=>{
      spawnExplosion(x+rnd(-20,20), y+rnd(-15,15), 16, 4, 25, 4, ['#FFF','#FFA','#FF8','#F60','#F40']);
      for(let i=0;i<4;i++){
        const a = rnd(0, Math.PI*2), s = rnd(1,3);
        spawnParticle(x, y, Math.cos(a)*s, Math.sin(a)*s, 30, rnd(2,5), ['#FF8','#F80','#840'], 0.05, 0.97, 'square');
      }
    }, w*100);
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vy += p.gravity;
    p.vx *= p.friction; p.vy *= p.friction;
    p.rotation += p.rotSpeed;
    p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles(ctx) {
  particles.forEach(p => {
    const t = 1 - p.life / p.maxLife;
    const ci = Math.min(Math.floor(t * p.colors.length), p.colors.length-1);
    const alpha = p.life / p.maxLife;
    const sz = p.size * (1 - t * 0.5);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.colors[ci];
    if (p.shape === 'circle') {
      ctx.beginPath(); ctx.arc(p.x, p.y, sz, 0, Math.PI*2); ctx.fill();
    } else {
      ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.rotation);
      ctx.fillRect(-sz, -sz, sz*2, sz*2); ctx.restore();
    }
  });
  ctx.globalAlpha = 1;
}

// ==================== SCREEN SHAKE ====================
let shakeX = 0, shakeY = 0, shakeAmp = 0, shakeDur = 0;
function triggerShake(amp, dur) { shakeAmp = amp; shakeDur = dur; }
function updateShake() {
  if (shakeDur > 0) {
    shakeDur--;
    const decay = shakeDur / 30;
    shakeX = (Math.random()-0.5) * shakeAmp * 2 * Math.min(decay, 1);
    shakeY = (Math.random()-0.5) * shakeAmp * 2 * Math.min(decay, 1);
  } else { shakeX = 0; shakeY = 0; }
}

// ==================== SPRITE DRAWING ====================
function drawVicViper(ctx, x, y, frame, invincible=false) {
  if (invincible && frame % 4 < 2) return;
  ctx.save(); ctx.translate(x, y);
  // Body
  ctx.fillStyle = '#B0B0B0';
  ctx.fillRect(-12, -3, 24, 6);
  ctx.fillStyle = '#E0E0E0';
  ctx.fillRect(-10, -5, 18, 3);
  ctx.fillRect(-10, 2, 18, 3);
  // Nose
  ctx.fillStyle = '#D0D0D0';
  ctx.fillRect(12, -2, 6, 4);
  ctx.fillStyle = '#FFF';
  ctx.fillRect(16, -1, 3, 2);
  // Wings
  ctx.fillStyle = '#A0A0A0';
  ctx.fillRect(-8, -8, 14, 3);
  ctx.fillRect(-8, 5, 14, 3);
  // Cockpit
  ctx.fillStyle = '#4488FF';
  ctx.fillRect(2, -2, 5, 4);
  ctx.fillStyle = '#66AAFF';
  ctx.fillRect(3, -1, 3, 2);
  // Engine glow
  const flicker = Math.sin(frame*0.5)*0.3+0.7;
  ctx.fillStyle = `rgba(255,${Math.floor(100+flicker*80)},0,${flicker})`;
  ctx.fillRect(-15, -2, 4, 4);
  ctx.fillStyle = `rgba(255,${Math.floor(180+flicker*50)},0,${flicker*0.7})`;
  ctx.fillRect(-17, -1, 3, 2);
  ctx.restore();
}

function drawOption(ctx, x, y, frame) {
  const pulse = Math.sin(frame * 0.15) * 0.3 + 0.7;
  const r = CONFIG.OPTION_RADIUS;
  ctx.save();
  ctx.globalAlpha = 0.3;
  ctx.fillStyle = '#FF8800';
  ctx.beginPath(); ctx.arc(x, y, r+3, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;
  const grad = ctx.createRadialGradient(x-1, y-1, 0, x, y, r);
  grad.addColorStop(0, '#FFDD44');
  grad.addColorStop(0.5, `rgba(255,136,0,${pulse})`);
  grad.addColorStop(1, 'rgba(255,68,0,0.6)');
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#FFF';
  ctx.globalAlpha = pulse * 0.5;
  ctx.beginPath(); ctx.arc(x-2, y-2, r*0.35, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;
  ctx.restore();
}

function drawShield(ctx, x, y, hp, frame) {
  const alpha = 0.3 + Math.sin(frame*0.1)*0.1;
  const hpRatio = hp / CONFIG.SHIELD_MAX_HP;
  ctx.save();
  ctx.strokeStyle = hpRatio > 0.3 ? `rgba(0,204,255,${alpha})` : `rgba(255,68,68,${alpha})`;
  ctx.lineWidth = 2 + hpRatio;
  ctx.beginPath();
  ctx.arc(x + 14, y, 14, -Math.PI*0.45, Math.PI*0.45);
  ctx.stroke();
  ctx.globalAlpha = alpha * 0.3;
  ctx.fillStyle = hpRatio > 0.3 ? '#0CF' : '#F44';
  ctx.beginPath();
  ctx.arc(x + 14, y, 12, -Math.PI*0.4, Math.PI*0.4);
  ctx.fill();
  ctx.restore();
}

function drawEnemy(ctx, type, x, y, frame, hp, maxHp) {
  ctx.save(); ctx.translate(x, y);
  switch(type) {
    case 'fan': {
      ctx.fillStyle = '#FF4444';
      ctx.save(); ctx.rotate(frame * 0.1);
      ctx.beginPath();
      ctx.moveTo(0,-7); ctx.lineTo(7,0); ctx.lineTo(0,7); ctx.lineTo(-7,0);
      ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#FF8866';
      ctx.beginPath();
      ctx.moveTo(0,-4); ctx.lineTo(4,0); ctx.lineTo(0,4); ctx.lineTo(-4,0);
      ctx.closePath(); ctx.fill();
      ctx.restore();
      break;
    }
    case 'ducker': {
      ctx.fillStyle = '#888';
      ctx.fillRect(-8, -4, 16, 8);
      ctx.fillStyle = '#666';
      ctx.beginPath(); ctx.arc(0, -4, 8, Math.PI, 0); ctx.fill();
      ctx.fillStyle = '#FFAA00';
      ctx.fillRect(-2, -8, 4, 5);
      break;
    }
    case 'jumper': {
      ctx.fillStyle = '#44FF44';
      ctx.beginPath();
      ctx.moveTo(0, -6); ctx.lineTo(6, 6); ctx.lineTo(-6, 6);
      ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#88FF88';
      ctx.beginPath();
      ctx.moveTo(0, -3); ctx.lineTo(3, 4); ctx.lineTo(-3, 4);
      ctx.closePath(); ctx.fill();
      break;
    }
    case 'rush': {
      ctx.fillStyle = '#FF8800';
      ctx.beginPath();
      ctx.moveTo(10, 0); ctx.lineTo(-10, -4); ctx.lineTo(-8, 0); ctx.lineTo(-10, 4);
      ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#FFAA44';
      ctx.fillRect(-6, -1, 10, 2);
      break;
    }
    case 'garun': {
      const pulse = Math.sin(frame*0.2)*0.3+0.7;
      ctx.fillStyle = `rgba(204,68,255,${pulse})`;
      ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#EE88FF';
      ctx.beginPath(); ctx.arc(-1, -1, 2, 0, Math.PI*2); ctx.fill();
      break;
    }
    case 'hatch': {
      ctx.fillStyle = '#666';
      ctx.fillRect(-10, -4, 20, 8);
      ctx.fillStyle = '#444';
      ctx.fillRect(-8, -3, 16, 6);
      const open = Math.sin(frame*0.05) > 0;
      if(open) { ctx.fillStyle = '#F00'; ctx.fillRect(-6, -2, 12, 4); }
      break;
    }
    case 'moai': {
      ctx.fillStyle = '#CCAA66';
      ctx.fillRect(-12, -16, 24, 32);
      ctx.fillStyle = '#AA8844';
      ctx.fillRect(-10, -20, 20, 6);
      // Eyes
      ctx.fillStyle = '#FF4444';
      const eyePulse = Math.sin(frame*0.08)*0.3+0.7;
      ctx.globalAlpha = eyePulse;
      ctx.fillRect(-8, -10, 4, 4);
      ctx.fillRect(2, -10, 4, 4);
      ctx.globalAlpha = 1;
      // Mouth
      const mouthOpen = Math.sin(frame*0.03) > 0;
      if(mouthOpen) {
        ctx.fillStyle = '#442200';
        ctx.fillRect(-6, 2, 10, 6);
      }
      break;
    }
  }
  // HP bar for multi-hit enemies
  if (maxHp > 1 && hp < maxHp) {
    ctx.fillStyle = '#400';
    ctx.fillRect(-10, -20, 20, 2);
    ctx.fillStyle = '#F44';
    ctx.fillRect(-10, -20, 20 * (hp/maxHp), 2);
  }
  ctx.restore();
}

function drawBoss(ctx, boss, frame) {
  const {x, y, type, hp, maxHp, phase, mouthOpen} = boss;
  ctx.save(); ctx.translate(x, y);
  
  const hpRatio = hp / maxHp;
  const dmgFlash = boss.dmgFlash > 0;
  
  switch(type) {
    case 'volcano_dragon': {
      // Body mass emerging from right
      ctx.fillStyle = dmgFlash ? '#FFF' : '#884400';
      ctx.fillRect(10, -30, 60, 60);
      ctx.fillStyle = dmgFlash ? '#FFF' : '#AA6622';
      // Head
      ctx.beginPath();
      ctx.moveTo(-32, -20); ctx.lineTo(10, -30); ctx.lineTo(10, 30); ctx.lineTo(-32, 20);
      ctx.lineTo(-40, 10); ctx.lineTo(-40, -10);
      ctx.closePath(); ctx.fill();
      // Jaw
      ctx.fillStyle = dmgFlash ? '#FFF' : '#774400';
      ctx.beginPath();
      ctx.moveTo(-38, 0); ctx.lineTo(-32, mouthOpen ? 18 : 8);
      ctx.lineTo(5, mouthOpen ? 24 : 12); ctx.lineTo(5, 0);
      ctx.closePath(); ctx.fill();
      // Upper jaw
      ctx.fillStyle = dmgFlash ? '#FFF' : '#996622';
      ctx.beginPath();
      ctx.moveTo(-38, 0); ctx.lineTo(-32, mouthOpen ? -18 : -8);
      ctx.lineTo(5, mouthOpen ? -24 : -12); ctx.lineTo(5, 0);
      ctx.closePath(); ctx.fill();
      // Eye
      ctx.fillStyle = '#FF0';
      ctx.beginPath(); ctx.arc(-20, -10, 4, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#F00';
      ctx.beginPath(); ctx.arc(-20, -10, 2, 0, Math.PI*2); ctx.fill();
      // Core (visible when mouth open)
      if (mouthOpen) {
        const corePulse = Math.sin(frame*0.2)*0.3+0.7;
        ctx.fillStyle = `rgba(255,0,68,${corePulse})`;
        ctx.beginPath(); ctx.arc(-10, 0, 8, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = `rgba(255,100,100,${corePulse*0.5})`;
        ctx.beginPath(); ctx.arc(-10, 0, 12, 0, Math.PI*2); ctx.fill();
      }
      // Armor detail
      ctx.strokeStyle = '#664400'; ctx.lineWidth = 1;
      for(let i=-25;i<10;i+=8){
        ctx.beginPath(); ctx.moveTo(i,-25); ctx.lineTo(i+5,-28); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(i,25); ctx.lineTo(i+5,28); ctx.stroke();
      }
      break;
    }
    case 'moai_titan': {
      // Giant Moai head
      ctx.fillStyle = dmgFlash ? '#FFF' : '#BBAA77';
      ctx.fillRect(-40, -48, 80, 96);
      ctx.fillStyle = dmgFlash ? '#FFF' : '#998855';
      // Forehead
      ctx.fillRect(-35, -52, 70, 10);
      ctx.fillRect(-30, -56, 60, 6);
      // Brow ridge
      ctx.fillStyle = dmgFlash ? '#FFF' : '#887744';
      ctx.fillRect(-38, -28, 76, 8);
      // Eyes
      const eyeGlow = Math.sin(frame*0.1)*0.3+0.7;
      ctx.fillStyle = `rgba(255,68,68,${eyeGlow})`;
      ctx.fillRect(-30, -24, 12, 10);
      ctx.fillRect(10, -24, 12, 10);
      ctx.fillStyle = '#FF8888';
      ctx.fillRect(-28, -22, 4, 4);
      ctx.fillRect(12, -22, 4, 4);
      // Nose
      ctx.fillStyle = dmgFlash ? '#FFF' : '#AA9966';
      ctx.fillRect(-8, -12, 16, 20);
      // Mouth
      ctx.fillStyle = '#442200';
      const mOpen = mouthOpen || true;
      ctx.fillRect(-20, 12, 40, mOpen ? 16 : 8);
      // Core in mouth
      if(mOpen) {
        const cp = Math.sin(frame*0.15)*0.3+0.7;
        ctx.fillStyle = `rgba(255,0,68,${cp})`;
        ctx.beginPath(); ctx.arc(0, 20, 6, 0, Math.PI*2); ctx.fill();
      }
      break;
    }
    case 'zeros_force': {
      // Tentacles
      if(boss.tentacles) {
        boss.tentacles.forEach((tent,i) => {
          if(tent.hp <= 0) return;
          const ta = boss.tentAngle + (Math.PI*2/4)*i;
          ctx.save();
          ctx.strokeStyle = dmgFlash ? '#FFF' : '#6644AA';
          ctx.lineWidth = 4;
          ctx.beginPath();
          for(let j=0;j<8;j++){
            const seg = j*8;
            const sx = Math.cos(ta+Math.sin(frame*0.05+j*0.5)*0.3)*seg;
            const sy = Math.sin(ta+Math.sin(frame*0.05+j*0.5)*0.3)*seg;
            j===0 ? ctx.moveTo(sx,sy) : ctx.lineTo(sx,sy);
          }
          ctx.stroke();
          // Tentacle tip
          const tipX = Math.cos(ta)*56;
          const tipY = Math.sin(ta)*56;
          ctx.fillStyle = dmgFlash ? '#FFF' : '#8866CC';
          ctx.beginPath(); ctx.arc(tipX, tipY, 5, 0, Math.PI*2); ctx.fill();
          ctx.restore();
        });
      }
      // Shield ring
      if(boss.shieldActive) {
        ctx.save();
        ctx.strokeStyle = `rgba(68,170,255,${0.3+Math.sin(frame*0.1)*0.15})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, 30, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
      // Core
      const corePulse = Math.sin(frame*0.08)*0.15+0.85;
      const coreSize = 20 * corePulse;
      ctx.fillStyle = dmgFlash ? '#FFF' : `rgba(255,34,102,${corePulse})`;
      ctx.beginPath(); ctx.arc(0, 0, coreSize, 0, Math.PI*2); ctx.fill();
      // Brain texture
      ctx.strokeStyle = `rgba(255,100,150,${corePulse*0.5})`;
      ctx.lineWidth = 1;
      for(let i=0;i<5;i++){
        ctx.beginPath();
        ctx.arc(rnd(-5,5), rnd(-5,5), rnd(5,15), rnd(0,Math.PI), rnd(Math.PI,Math.PI*2));
        ctx.stroke();
      }
      // Inner glow
      ctx.fillStyle = `rgba(255,150,200,${corePulse*0.3})`;
      ctx.beginPath(); ctx.arc(0, 0, coreSize*0.5, 0, Math.PI*2); ctx.fill();
      break;
    }
  }
  
  // Boss HP bar
  ctx.restore();
  ctx.fillStyle = '#400';
  ctx.fillRect(W*0.2, 12, W*0.6, 4);
  ctx.fillStyle = hpRatio > 0.3 ? '#F44' : '#FF0';
  ctx.fillRect(W*0.2, 12, W*0.6*hpRatio, 4);
  ctx.strokeStyle = '#888';
  ctx.strokeRect(W*0.2, 12, W*0.6, 4);
}

// ==================== CRT EFFECT ====================
function drawCRT(ctx) {
  // Scanlines
  ctx.fillStyle = `rgba(0,0,0,${CONFIG.CRT_SCANLINE_OPACITY})`;
  for (let y = 0; y < H; y += 3) {
    ctx.fillRect(0, y, W, 1);
  }
  // Vignette
  const cx = W/2, cy = H/2, r = Math.max(W,H)*0.7;
  const grad = ctx.createRadialGradient(cx, cy, r*0.5, cx, cy, r);
  grad.addColorStop(0, 'rgba(0,0,0,0)');
  grad.addColorStop(1, `rgba(0,0,0,${CONFIG.CRT_VIGNETTE_STRENGTH})`);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
}

// ==================== STAGE DATA ====================
function getStageData(stageNum) {
  const stages = [
    { // Stage 1: Volcanic Inferno
      scrollSpeed: 1.2, length: 6000, bgm: 'stage1',
      colors: { sky1:'#1A0505', sky2:'#3A0A0A', rock:'#443322', rock2:'#332211', lava:'#FF4400' },
      terrain: {
        top: [{x:0,y:0},{x:800,y:0},{x:1500,y:0},{x:1800,y:50},{x:2200,y:70},{x:2600,y:50},
              {x:3000,y:30},{x:3200,y:60},{x:3600,y:80},{x:4000,y:90},{x:4400,y:70},
              {x:4800,y:100},{x:5200,y:80},{x:5600,y:50},{x:6000,y:0},{x:6500,y:0}],
        bottom: [{x:0,y:H},{x:800,y:H},{x:1500,y:H},{x:1800,y:260},{x:2200,y:240},{x:2600,y:260},
                 {x:3000,y:280},{x:3200,y:250},{x:3600,y:230},{x:4000,y:220},{x:4400,y:240},
                 {x:4800,y:210},{x:5200,y:230},{x:5600,y:270},{x:6000,y:H},{x:6500,y:H}]
      },
      spawns: [
        {x:400, type:'fan', count:5, y:80, formation:'line', powerUp:false},
        {x:600, type:'fan', count:5, y:200, formation:'line', powerUp:false},
        {x:900, type:'rush', count:5, y:160, formation:'line', powerUp:true},
        {x:1200, type:'fan', count:4, y:120, formation:'sine', powerUp:false},
        {x:1500, type:'rush', count:5, y:100, formation:'line', powerUp:true},
        {x:1800, type:'fan', count:3, y:180, formation:'sine', powerUp:false},
        {x:2000, type:'ducker', count:1, y:230, formation:'ground', powerUp:false},
        {x:2200, type:'fan', count:5, y:140, formation:'line', powerUp:false},
        {x:2400, type:'garun', count:5, y:150, formation:'circle', powerUp:true},
        {x:2700, type:'ducker', count:1, y:230, formation:'ground', powerUp:false},
        {x:2900, type:'rush', count:5, y:120, formation:'line', powerUp:true},
        {x:3200, type:'fan', count:4, y:100, formation:'sine', powerUp:false},
        {x:3400, type:'fan', count:4, y:200, formation:'sine', powerUp:false},
        {x:3700, type:'ducker', count:2, y:210, formation:'ground', powerUp:false},
        {x:3900, type:'garun', count:5, y:160, formation:'circle', powerUp:true},
        {x:4200, type:'hatch', count:1, y:210, formation:'fixed', powerUp:false},
        {x:4400, type:'rush', count:5, y:140, formation:'line', powerUp:true},
        {x:4600, type:'fan', count:5, y:100, formation:'line', powerUp:false},
        {x:4800, type:'hatch', count:1, y:100, formation:'fixedTop', powerUp:false},
        {x:5000, type:'fan', count:6, y:160, formation:'sine', powerUp:false},
        {x:5200, type:'rush', count:5, y:130, formation:'line', powerUp:true},
        {x:5500, type:'garun', count:5, y:160, formation:'circle', powerUp:true},
        {x:5700, type:'fan', count:5, y:200, formation:'line', powerUp:false},
      ],
      boss: { type:'volcano_dragon', hp:80 }
    },
    { // Stage 2: Stone Monument
      scrollSpeed: 1.2, length: 6000, bgm: 'stage2',
      colors: { sky1:'#0A0A2E', sky2:'#1A1A4E', rock:'#BBAA77', rock2:'#998855', lava:'#DDCC99' },
      terrain: {
        top: [{x:0,y:0},{x:1000,y:0},{x:1500,y:40},{x:2000,y:0},{x:2500,y:60},{x:3000,y:80},
              {x:3500,y:60},{x:4000,y:90},{x:4500,y:50},{x:5000,y:70},{x:5500,y:30},{x:6000,y:0},{x:6500,y:0}],
        bottom: [{x:0,y:H},{x:1000,y:H},{x:1500,y:270},{x:2000,y:H},{x:2500,y:260},{x:3000,y:240},
                 {x:3500,y:260},{x:4000,y:230},{x:4500,y:260},{x:5000,y:250},{x:5500,y:280},{x:6000,y:H},{x:6500,y:H}]
      },
      spawns: [
        {x:400, type:'fan', count:5, y:100, formation:'line', powerUp:false},
        {x:700, type:'rush', count:5, y:160, formation:'line', powerUp:true},
        {x:1000, type:'fan', count:4, y:200, formation:'sine', powerUp:false},
        {x:1300, type:'jumper', count:3, y:260, formation:'ground', powerUp:false},
        {x:1600, type:'moai', count:1, y:200, formation:'fixed', powerUp:false},
        {x:1900, type:'garun', count:5, y:120, formation:'circle', powerUp:true},
        {x:2200, type:'moai', count:1, y:100, formation:'fixedTop', powerUp:false},
        {x:2200, type:'moai', count:1, y:220, formation:'fixed', powerUp:false},
        {x:2500, type:'rush', count:5, y:160, formation:'line', powerUp:true},
        {x:2800, type:'jumper', count:4, y:250, formation:'ground', powerUp:false},
        {x:3100, type:'moai', count:1, y:160, formation:'fixed', powerUp:false},
        {x:3400, type:'fan', count:5, y:80, formation:'sine', powerUp:false},
        {x:3700, type:'garun', count:5, y:160, formation:'circle', powerUp:true},
        {x:4000, type:'moai', count:1, y:120, formation:'fixedTop', powerUp:false},
        {x:4000, type:'moai', count:1, y:210, formation:'fixed', powerUp:false},
        {x:4300, type:'rush', count:5, y:140, formation:'line', powerUp:true},
        {x:4600, type:'jumper', count:3, y:240, formation:'ground', powerUp:false},
        {x:4900, type:'fan', count:6, y:160, formation:'sine', powerUp:false},
        {x:5200, type:'garun', count:5, y:120, formation:'circle', powerUp:true},
        {x:5500, type:'fan', count:5, y:200, formation:'line', powerUp:false},
      ],
      boss: { type:'moai_titan', hp:120 }
    },
    { // Stage 3: Fortress of Doom
      scrollSpeed: 1.5, length: 6000, bgm: 'stage3',
      colors: { sky1:'#050510', sky2:'#0A0A20', rock:'#556677', rock2:'#445566', lava:'#334455' },
      terrain: {
        top: [{x:0,y:0},{x:600,y:40},{x:1200,y:60},{x:1800,y:40},{x:2400,y:80},{x:3000,y:100},
              {x:3500,y:70},{x:4000,y:90},{x:4500,y:110},{x:5000,y:80},{x:5500,y:100},{x:6000,y:60},{x:6500,y:0}],
        bottom: [{x:0,y:H},{x:600,y:280},{x:1200,y:260},{x:1800,y:280},{x:2400,y:240},{x:3000,y:220},
                 {x:3500,y:250},{x:4000,y:230},{x:4500,y:210},{x:5000,y:240},{x:5500,y:220},{x:6000,y:260},{x:6500,y:H}]
      },
      spawns: [
        {x:300, type:'fan', count:5, y:100, formation:'line', powerUp:false},
        {x:500, type:'ducker', count:2, y:260, formation:'ground', powerUp:false},
        {x:800, type:'rush', count:5, y:160, formation:'line', powerUp:true},
        {x:1100, type:'fan', count:5, y:200, formation:'sine', powerUp:false},
        {x:1400, type:'garun', count:5, y:140, formation:'circle', powerUp:true},
        {x:1700, type:'hatch', count:1, y:100, formation:'fixedTop', powerUp:false},
        {x:1700, type:'ducker', count:2, y:250, formation:'ground', powerUp:false},
        {x:2000, type:'rush', count:5, y:120, formation:'line', powerUp:true},
        {x:2300, type:'fan', count:6, y:160, formation:'sine', powerUp:false},
        {x:2600, type:'hatch', count:1, y:210, formation:'fixed', powerUp:false},
        {x:2900, type:'garun', count:5, y:160, formation:'circle', powerUp:true},
        {x:3200, type:'rush', count:5, y:100, formation:'line', powerUp:true},
        {x:3500, type:'fan', count:5, y:200, formation:'line', powerUp:false},
        {x:3800, type:'ducker', count:2, y:220, formation:'ground', powerUp:false},
        {x:4100, type:'hatch', count:1, y:100, formation:'fixedTop', powerUp:false},
        {x:4100, type:'hatch', count:1, y:220, formation:'fixed', powerUp:false},
        {x:4400, type:'rush', count:5, y:160, formation:'line', powerUp:true},
        {x:4700, type:'fan', count:6, y:140, formation:'sine', powerUp:false},
        {x:5000, type:'garun', count:5, y:160, formation:'circle', powerUp:true},
        {x:5300, type:'rush', count:5, y:120, formation:'line', powerUp:true},
        {x:5600, type:'fan', count:5, y:200, formation:'sine', powerUp:false},
      ],
      boss: { type:'zeros_force', hp:150 }
    }
  ];
  return stages[stageNum - 1];
}

// ==================== TERRAIN HELPERS ====================
function getTerrainY(points, worldX) {
  for (let i = 0; i < points.length - 1; i++) {
    if (worldX >= points[i].x && worldX <= points[i+1].x) {
      const t = (worldX - points[i].x) / (points[i+1].x - points[i].x);
      return lerp(points[i].y, points[i+1].y, t);
    }
  }
  return points[points.length-1].y;
}

// ==================== MAIN GAME CLASS ====================
class Game {
  constructor() {
    this.state = 'title'; // title, playing, paused, gameover, stageclear, ending, warning
    this.frame = 0;
    this.stageNum = 1;
    this.score = 0;
    this.hiScore = 0;
    this.lives = CONFIG.PLAYER_INITIAL_LIVES;
    this.crtEnabled = true;
    this.debug = false;
    this.invincible = false;
    this.titleFrame = 0;
    this.gameOverTimer = 0;
    this.stageClearTimer = 0;
    this.endingTimer = 0;
    this.warningTimer = 0;
    this.flashAlpha = 0;
    this.stateTimer = 0;
    this.init();
  }

  init() {
    this.player = {
      x: CONFIG.PLAYER_START_X, y: CONFIG.PLAYER_START_Y,
      speedLevel: 0, hasMissile: false, hasDouble: false, hasLaser: false,
      optionCount: 0, shieldHp: 0,
      shotCooldown: 0, missileCooldown: 0, laserActive: false, laserTimer: 0,
      alive: true, respawnTimer: 0, invTimer: 0,
      posHistory: []
    };
    this.powerGauge = { cursor: -1, slots: ['SPD','MSL','DBL','LSR','OPT','  ?'] };
    this.playerBullets = [];
    this.enemyBullets = [];
    this.enemies = [];
    this.bosses = [];
    this.capsules = [];
    this.options = [];
    this.cameraX = 0;
    this.scrolling = true;
    this.spawnIndex = 0;
    this.stageData = null;
    this.bossActive = false;
    this.bossDefeated = false;
    this.formationKills = {};
    this.nextExtend = CONFIG.EXTEND_FIRST;
    this.noMiss = true;
    particles.length = 0;
  }

  startGame() {
    this.score = 0;
    this.lives = CONFIG.PLAYER_INITIAL_LIVES;
    this.stageNum = 1;
    this.nextExtend = CONFIG.EXTEND_FIRST;
    this.startStage(1);
  }

  startStage(num) {
    this.stageNum = num;
    this.stageData = getStageData(num);
    this.cameraX = 0;
    this.scrolling = true;
    this.spawnIndex = 0;
    this.bossActive = false;
    this.bossDefeated = false;
    this.playerBullets = [];
    this.enemyBullets = [];
    this.enemies = [];
    this.bosses = [];
    this.capsules = [];
    this.formationKills = {};
    this.noMiss = true;
    particles.length = 0;
    
    this.player.x = CONFIG.PLAYER_START_X;
    this.player.y = CONFIG.PLAYER_START_Y;
    this.player.alive = true;
    this.player.respawnTimer = 0;
    this.player.invTimer = 90;
    this.player.posHistory = [];
    this.player.laserActive = false;
    
    this.state = 'warning';
    this.warningTimer = 120;
    this.stateTimer = 0;
    
    audio.playBGM(this.stageData.bgm);
  }

  addScore(pts) {
    this.score += pts;
    if (this.score > this.hiScore) this.hiScore = this.score;
    if (this.score >= this.nextExtend) {
      this.lives = Math.min(this.lives + 1, CONFIG.PLAYER_MAX_LIVES);
      this.nextExtend += CONFIG.EXTEND_EVERY;
      // 1UP sound
      audio.playSE('powerup');
    }
  }

  activatePowerUp() {
    const p = this.player;
    const c = this.powerGauge.cursor;
    if (c < 0) return;
    audio.playSE('powerup');
    switch(c) {
      case 0: // SPEED UP
        if (p.speedLevel < CONFIG.PLAYER_MAX_SPEED_LEVEL) p.speedLevel++;
        break;
      case 1: // MISSILE
        p.hasMissile = true;
        break;
      case 2: // DOUBLE
        p.hasDouble = true;
        p.hasLaser = false;
        break;
      case 3: // LASER
        p.hasLaser = true;
        p.hasDouble = false;
        break;
      case 4: // OPTION
        if (p.optionCount < CONFIG.OPTION_MAX) {
          p.optionCount++;
          this.options.push({ x: p.x, y: p.y });
        }
        break;
      case 5: // SHIELD
        p.shieldHp = CONFIG.SHIELD_MAX_HP;
        break;
    }
    this.powerGauge.cursor = -1;
  }

  playerDie() {
    if (this.invincible) return;
    if (!this.player.alive) return;
    this.player.alive = false;
    this.player.respawnTimer = 120;
    this.noMiss = false;
    audio.playSE('playerDeath');
    spawnBigExplosion(this.player.x, this.player.y);
    triggerShake(4, 20);
    
    // Reset powerups
    this.player.speedLevel = 0;
    this.player.hasMissile = false;
    this.player.hasDouble = false;
    this.player.hasLaser = false;
    this.player.optionCount = 0;
    this.player.shieldHp = 0;
    this.player.laserActive = false;
    this.options = [];
    this.powerGauge.cursor = -1;
    
    this.lives--;
    if (this.lives < 0) {
      this.state = 'gameover';
      this.gameOverTimer = 0;
      audio.stopBGM();
    }
  }

  respawnPlayer() {
    this.player.alive = true;
    this.player.x = CONFIG.PLAYER_START_X;
    this.player.y = H / 2;
    this.player.invTimer = 120;
    this.player.posHistory = [];
  }

  spawnEnemyFormation(spawn) {
    const fid = `${spawn.x}_${spawn.type}`;
    this.formationKills[fid] = { total: spawn.count, killed: 0, powerUp: spawn.powerUp };
    
    for (let i = 0; i < spawn.count; i++) {
      const e = {
        type: spawn.type,
        x: W + this.cameraX + 20 + i * 30,
        y: spawn.y || H/2,
        hp: 1, maxHp: 1,
        vx: -2, vy: 0,
        formationId: fid,
        timer: 0, phase: 0,
        baseY: spawn.y || H/2,
        spawnIndex: i,
        active: true,
        // Formation-specific
        formation: spawn.formation,
        circleAngle: (Math.PI*2/spawn.count)*i,
        circleCenterX: W + this.cameraX + 60,
        circleCenterY: spawn.y || H/2,
      };
      
      // Type-specific stats
      switch(spawn.type) {
        case 'fan': e.hp = 1; e.maxHp = 1; e.score = 100; break;
        case 'rush': e.hp = 1; e.maxHp = 1; e.score = 150; e.vx = -5; break;
        case 'ducker': e.hp = 1; e.maxHp = 1; e.score = 200; e.vx = -0.5; e.shootInterval = 120; break;
        case 'jumper': e.hp = 1; e.maxHp = 1; e.score = 150; e.vy = -4; e.gravity = 0.12; break;
        case 'garun': e.hp = 1; e.maxHp = 1; e.score = 100; break;
        case 'hatch': e.hp = 5; e.maxHp = 5; e.score = 500; e.vx = 0; e.spawnTimer = 0; break;
        case 'moai': e.hp = 10; e.maxHp = 10; e.score = 1000; e.vx = 0; e.mouthOpen = false; e.mouthTimer = 0; break;
      }
      
      // Ground enemies position
      if (spawn.formation === 'ground' || spawn.formation === 'fixed') {
        e.x = spawn.x + i * 40;
        e.grounded = true;
      }
      if (spawn.formation === 'fixedTop') {
        e.x = spawn.x;
        e.y = spawn.y || 60;
        e.grounded = false;
      }
      if (spawn.formation === 'fixed') {
        e.x = spawn.x;
      }
      
      this.enemies.push(e);
    }
  }

  spawnBoss() {
    const bd = this.stageData.boss;
    const boss = {
      type: bd.type, x: W - 60, y: H / 2,
      hp: bd.hp, maxHp: bd.hp,
      phase: 0, timer: 0, mouthOpen: false, mouthTimer: 0,
      dmgFlash: 0, active: true, defeated: false,
      baseY: H/2, moveTimer: 0, attackTimer: 0,
      tentacles: null, tentAngle: 0, shieldActive: false,
      chargeTimer: 0, charging: false, chargeDir: 0
    };
    
    if (bd.type === 'zeros_force') {
      boss.tentacles = [{hp:20,maxHp:20},{hp:20,maxHp:20},{hp:20,maxHp:20},{hp:20,maxHp:20}];
      boss.x = W - 100; boss.y = H/2;
    }
    if (bd.type === 'moai_titan') {
      boss.x = W - 50;
    }
    
    this.bosses.push(boss);
    this.bossActive = true;
    audio.playSE('warning');
    audio.playBGM('boss');
  }

  updateBoss(boss) {
    boss.timer++;
    boss.moveTimer++;
    boss.attackTimer++;
    if (boss.dmgFlash > 0) boss.dmgFlash--;
    
    switch(boss.type) {
      case 'volcano_dragon': {
        const phase2 = boss.hp < boss.maxHp * 0.5;
        const speed = phase2 ? 1.5 : 0.8;
        boss.y = boss.baseY + Math.sin(boss.moveTimer * 0.02 * speed) * 60;
        
        // Mouth open/close
        boss.mouthTimer++;
        const cycleDur = phase2 ? 150 : 210;
        const openDur = 90;
        boss.mouthOpen = (boss.mouthTimer % cycleDur) < openDur;
        
        // Fire bullets
        const fireInterval = phase2 ? 60 : 120;
        if (boss.attackTimer % fireInterval === 0) {
          const ways = phase2 ? 5 : 3;
          const baseAngle = angleTo(boss.x-10, boss.y, this.player.x, this.player.y);
          for (let i = 0; i < ways; i++) {
            const a = baseAngle + (i - (ways-1)/2) * 0.2;
            this.enemyBullets.push({
              x: boss.x - 20, y: boss.y,
              vx: Math.cos(a) * 3, vy: Math.sin(a) * 3,
              size: 4, color: '#FF4400'
            });
          }
        }
        
        // Homing missiles
        const missileInterval = phase2 ? 90 : 180;
        if (boss.attackTimer % missileInterval === 0) {
          const count = phase2 ? 4 : 2;
          for (let i = 0; i < count; i++) {
            const a = angleTo(boss.x, boss.y - 20, this.player.x, this.player.y) + rnd(-0.3, 0.3);
            this.enemyBullets.push({
              x: boss.x, y: boss.y - 20 + i * 10,
              vx: Math.cos(a) * 2, vy: Math.sin(a) * 2,
              size: 3, color: '#FF8800', homing: true, homingStr: 0.02
            });
          }
        }
        
        // Phase 2: charge attack
        if (phase2 && boss.attackTimer % 300 === 150) {
          boss.charging = true;
          boss.chargeTimer = 60;
        }
        if (boss.charging) {
          boss.chargeTimer--;
          boss.x += boss.chargeTimer > 30 ? -2 : 2;
          if (boss.chargeTimer <= 0) { boss.charging = false; boss.x = W - 60; }
        }
        break;
      }
      
      case 'moai_titan': {
        boss.mouthOpen = true;
        const phase = boss.hp > boss.maxHp*0.6 ? 1 : boss.hp > boss.maxHp*0.3 ? 2 : 3;
        const speedMult = phase === 3 ? 0.7 : 1;
        
        boss.y = boss.baseY + Math.sin(boss.moveTimer * 0.015) * 30;
        
        // Ion rings from mouth
        const ringInterval = Math.floor((phase === 1 ? 120 : 80) * speedMult);
        if (boss.attackTimer % ringInterval === 0) {
          const count = phase >= 2 ? 2 : 1;
          for(let i=0;i<count;i++){
            this.enemyBullets.push({
              x: boss.x - 25, y: boss.y + 20 + i*8,
              vx: -2, vy: rnd(-0.5,0.5),
              size: 8, color: '#AAFFAA', ring: true, ringHp: 3
            });
          }
        }
        
        // Eye lasers
        const laserInterval = Math.floor(180 * speedMult);
        if (boss.attackTimer % laserInterval === 0) {
          for (let ey = -1; ey <= (phase >= 2 ? 1 : -1); ey += 2) {
            for(let i=0;i<8;i++){
              this.enemyBullets.push({
                x: boss.x - 30, y: boss.y - 22 + ey * 0,
                vx: -4 - i*0.3, vy: ey * (0.5 + i*0.2),
                size: 2, color: '#FF4444'
              });
            }
          }
        }
        
        // Phase 2: debris
        if (phase >= 2 && boss.attackTimer % Math.floor(240 * speedMult) === 0) {
          for(let i=0;i<8;i++){
            const a = (Math.PI*2/8)*i;
            this.enemyBullets.push({
              x: boss.x, y: boss.y,
              vx: Math.cos(a)*2.5, vy: Math.sin(a)*2.5,
              size: 3, color: '#CCAA66'
            });
          }
        }
        
        // Phase 3: advance
        if (phase === 3) {
          boss.x = (W - 50) + Math.sin(boss.moveTimer * 0.03) * 30;
        }
        break;
      }
      
      case 'zeros_force': {
        const phase = boss.hp > boss.maxHp*0.7 ? 1 : boss.hp > boss.maxHp*0.4 ? 2 : 3;
        const rotSpeed = phase === 3 ? 0.05 : 0.03;
        boss.tentAngle += rotSpeed * (phase === 2 && Math.sin(boss.timer*0.01) > 0 ? -1 : 1);
        
        // Movement
        if (phase >= 2) {
          const moveSpeed = phase === 3 ? 1.5 : 0.8;
          boss.x = W - 120 + Math.sin(boss.moveTimer * 0.01) * 40 * moveSpeed;
          boss.y = H/2 + Math.cos(boss.moveTimer * 0.015) * 50;
        }
        
        // Shield check
        if (boss.tentacles) {
          const alive = boss.tentacles.filter(t=>t.hp>0).length;
          boss.shieldActive = phase >= 2 && alive > 2;
        }
        
        // Core burst
        const burstWays = phase === 1 ? 16 : phase === 2 ? 24 : 32;
        const burstInterval = phase === 3 ? 90 : 180;
        if (boss.attackTimer % burstInterval === 0) {
          const spiralOffset = phase === 3 ? boss.timer * 0.05 : 0;
          for(let i=0;i<burstWays;i++){
            const a = (Math.PI*2/burstWays)*i + spiralOffset;
            this.enemyBullets.push({
              x: boss.x, y: boss.y,
              vx: Math.cos(a)*2.5, vy: Math.sin(a)*2.5,
              size: 2, color: '#FF2266'
            });
          }
        }
        
        // Tentacle aimed shots
        if(boss.tentacles){
          boss.tentacles.forEach((tent,i) => {
            if(tent.hp <= 0) return;
            if(boss.attackTimer % 90 === i * 20) {
              const ta = boss.tentAngle + (Math.PI*2/4)*i;
              const tipX = boss.x + Math.cos(ta)*56;
              const tipY = boss.y + Math.sin(ta)*56;
              const a = angleTo(tipX, tipY, this.player.x, this.player.y);
              this.enemyBullets.push({
                x: tipX, y: tipY,
                vx: Math.cos(a)*3, vy: Math.sin(a)*3,
                size: 3, color: '#8866CC'
              });
            }
          });
        }
        
        // Phase 3: sweep laser
        if(phase === 3 && boss.attackTimer % 240 === 120){
          const safeY = rnd(60, H-60);
          for(let x=0; x<W; x+=12){
            for(let y=0; y<H; y+=20){
              if(Math.abs(y - safeY) < 40) continue;
              this.enemyBullets.push({
                x: x, y: y, vx: 0, vy: 0, size: 2, color: '#44AAFF', life: 30
              });
            }
          }
        }
        break;
      }
    }
  }

  damageBoss(boss, dmg=1) {
    if (boss.shieldActive) return;
    
    // Special vulnerability checks
    if (boss.type === 'volcano_dragon' && !boss.mouthOpen) return;
    
    boss.hp -= dmg;
    boss.dmgFlash = 4;
    triggerShake(1, 3);
    audio.playSE('enemyHit');
    
    if (boss.hp <= 0) {
      boss.defeated = true;
      boss.active = false;
      this.bossDefeated = true;
      
      // Score
      const bossScores = { volcano_dragon: 10000, moai_titan: 20000, zeros_force: 50000 };
      this.addScore(bossScores[boss.type] || 10000);
      
      // Epic death
      audio.playSE('explodeBig');
      triggerShake(6, 40);
      this.flashAlpha = 1;
      
      for(let i=0;i<8;i++){
        setTimeout(()=>{
          spawnBigExplosion(boss.x + rnd(-30,30), boss.y + rnd(-30,30));
          audio.playSE('explodeSmall');
        }, i*150);
      }
      
      // Stage clear
      setTimeout(() => {
        if (this.stageNum >= 3) {
          this.state = 'ending';
          this.endingTimer = 0;
          audio.stopBGM();
        } else {
          this.state = 'stageclear';
          this.stageClearTimer = 0;
          // Bonus
          this.addScore(5000 * this.stageNum);
          if (this.noMiss) this.addScore(10000);
        }
      }, 2000);
    }
  }

  update(input) {
    this.frame++;
    this.stateTimer++;
    updateShake();
    updateParticles();
    
    switch(this.state) {
      case 'title':
        this.titleFrame++;
        if (input.start) {
          audio.init();
          this.init();
          this.startGame();
        }
        break;
        
      case 'warning':
        this.warningTimer--;
        if (this.warningTimer <= 0) {
          this.state = 'playing';
        }
        break;
        
      case 'playing':
        this.updatePlaying(input);
        break;
        
      case 'paused':
        if (input.pause) this.state = 'playing';
        break;
        
      case 'gameover':
        this.gameOverTimer++;
        if (this.gameOverTimer > 180 && input.start) {
          this.state = 'title';
        }
        break;
        
      case 'stageclear':
        this.stageClearTimer++;
        if (this.stageClearTimer > 180) {
          this.startStage(this.stageNum + 1);
        }
        break;
        
      case 'ending':
        this.endingTimer++;
        if (this.endingTimer > 600 || (this.endingTimer > 120 && input.start)) {
          this.state = 'title';
          audio.stopBGM();
        }
        break;
    }
    
    // Flash decay
    if (this.flashAlpha > 0) this.flashAlpha *= 0.92;
    
    // Debug
    if (input.debugToggle) this.debug = !this.debug;
    if (input.invincible) this.invincible = !this.invincible;
    if (input.allPowerUp && this.state === 'playing') {
      const p = this.player;
      p.speedLevel = 3; p.hasMissile = true; p.hasLaser = true;
      if(p.optionCount < 4){ p.optionCount = 4; this.options = [{x:p.x,y:p.y},{x:p.x,y:p.y},{x:p.x,y:p.y},{x:p.x,y:p.y}]; }
      p.shieldHp = CONFIG.SHIELD_MAX_HP;
    }
    if (input.nextStage && this.state === 'playing') {
      if(this.stageNum < 3) this.startStage(this.stageNum + 1);
    }
  }

  updatePlaying(input) {
    const p = this.player;
    const sd = this.stageData;
    
    if (input.pause) { this.state = 'paused'; return; }
    if (input.fullscreen) {
      if(!document.fullscreenElement) canvas.requestFullscreen().catch(()=>{});
      else document.exitFullscreen();
    }
    
    // --- Scroll ---
    if (this.scrolling && !this.bossActive) {
      this.cameraX += sd.scrollSpeed;
      if (this.cameraX >= sd.length) {
        this.scrolling = false;
        this.spawnBoss();
      }
    }
    
    // --- Spawn enemies ---
    while (this.spawnIndex < sd.spawns.length && sd.spawns[this.spawnIndex].x <= this.cameraX + W) {
      this.spawnEnemyFormation(sd.spawns[this.spawnIndex]);
      this.spawnIndex++;
    }
    
    // --- Player ---
    if (p.alive) {
      const speed = CONFIG.PLAYER_BASE_SPEED + p.speedLevel * CONFIG.PLAYER_SPEED_INCREMENT;
      if (input.up) p.y -= speed;
      if (input.down) p.y += speed;
      if (input.left) p.x -= speed;
      if (input.right) p.x += speed;
      
      // Clamp to screen and terrain
      const topY = getTerrainY(sd.terrain.top, p.x + this.cameraX) + 10;
      const botY = getTerrainY(sd.terrain.bottom, p.x + this.cameraX) - 10;
      p.x = clamp(p.x, 10, W - 10);
      p.y = clamp(p.y, Math.max(10, topY), Math.min(H - 10, botY));
      
      // Terrain collision
      const terrTop = getTerrainY(sd.terrain.top, p.x + this.cameraX);
      const terrBot = getTerrainY(sd.terrain.bottom, p.x + this.cameraX);
      if (p.y - 5 < terrTop || p.y + 5 > terrBot) {
        this.playerDie();
      }
      
      // Record position for options
      p.posHistory.push({x: p.x, y: p.y});
      if (p.posHistory.length > CONFIG.OPTION_TRAIL_DELAY * (CONFIG.OPTION_MAX + 1) + 10) {
        p.posHistory.shift();
      }
      
      // Update options positions
      for (let i = 0; i < this.options.length; i++) {
        const delay = CONFIG.OPTION_TRAIL_DELAY * (i + 1);
        const idx = p.posHistory.length - 1 - delay;
        if (idx >= 0) {
          this.options[i].x = p.posHistory[idx].x;
          this.options[i].y = p.posHistory[idx].y;
        }
      }
      
      // Shooting
      if (p.shotCooldown > 0) p.shotCooldown--;
      if (p.missileCooldown > 0) p.missileCooldown--;
      
      if (input.shot && p.shotCooldown <= 0) {
        p.shotCooldown = CONFIG.PLAYER_SHOT_INTERVAL;
        
        if (p.hasLaser) {
          p.laserActive = true;
          p.laserTimer = 8;
          audio.playSE('laser');
        } else {
          // Normal shot (or Double)
          const shootPoints = [{x: p.x, y: p.y}];
          this.options.forEach(o => shootPoints.push({x: o.x, y: o.y}));
          
          shootPoints.forEach(sp => {
            this.playerBullets.push({
              x: sp.x + 12, y: sp.y,
              vx: CONFIG.PLAYER_BULLET_SPEED, vy: 0,
              size: 3, damage: 1, type: 'bullet'
            });
            if (p.hasDouble) {
              this.playerBullets.push({
                x: sp.x + 8, y: sp.y - 4,
                vx: CONFIG.PLAYER_BULLET_SPEED * 0.85, vy: -CONFIG.PLAYER_BULLET_SPEED * 0.5,
                size: 3, damage: 1, type: 'bullet'
              });
            }
          });
          audio.playSE('shot');
        }
      }
      
      // Laser update
      if (p.hasLaser && p.laserActive) {
        p.laserTimer--;
        if (p.laserTimer <= 0) p.laserActive = false;
      }
      
      // Missiles
      if (p.hasMissile && input.missile && p.missileCooldown <= 0) {
        p.missileCooldown = 20;
        const shootPoints = [{x: p.x, y: p.y}];
        this.options.forEach(o => shootPoints.push({x: o.x, y: o.y}));
        
        shootPoints.forEach(sp => {
          this.playerBullets.push({
            x: sp.x, y: sp.y + 4,
            vx: CONFIG.MISSILE_SPEED * 0.7, vy: CONFIG.MISSILE_SPEED * 0.7,
            size: 3, damage: 1, type: 'missile', grounded: false, gravity: CONFIG.MISSILE_GRAVITY
          });
        });
        audio.playSE('missile');
      }
      
      // Power up
      if (input.powerup && this.powerGauge.cursor >= 0) {
        this.activatePowerUp();
      }
      
      if (p.invTimer > 0) p.invTimer--;
    } else {
      // Dead - respawn timer
      p.respawnTimer--;
      if (p.respawnTimer <= 0 && this.lives >= 0) {
        this.respawnPlayer();
      }
    }
    
    // --- Update player bullets ---
    for (let i = this.playerBullets.length - 1; i >= 0; i--) {
      const b = this.playerBullets[i];
      if (b.type === 'missile') {
        if (!b.grounded) {
          b.vy += b.gravity;
          b.vx *= 0.99;
          const terrBot = getTerrainY(sd.terrain.bottom, b.x + this.cameraX);
          if (b.y >= terrBot - 4) {
            b.y = terrBot - 4;
            b.grounded = true;
            b.vx = CONFIG.MISSILE_GROUND_SPEED;
            b.vy = 0;
          }
        }
      }
      b.x += b.vx; b.y += b.vy;
      if (b.x > W + 10 || b.x < -10 || b.y > H + 10 || b.y < -10) {
        this.playerBullets.splice(i, 1);
      }
    }
    
    // --- Update enemy bullets ---
    for (let i = this.enemyBullets.length - 1; i >= 0; i--) {
      const b = this.enemyBullets[i];
      if (b.homing && p.alive) {
        const a = angleTo(b.x, b.y, p.x, p.y);
        b.vx += Math.cos(a) * b.homingStr;
        b.vy += Math.sin(a) * b.homingStr;
        const spd = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
        if(spd > 3) { b.vx = b.vx/spd*3; b.vy = b.vy/spd*3; }
      }
      b.x += b.vx; b.y += b.vy;
      if (b.life !== undefined) { b.life--; if(b.life<=0) { this.enemyBullets.splice(i,1); continue; } }
      if (b.x > W + 20 || b.x < -20 || b.y > H + 20 || b.y < -20) {
        this.enemyBullets.splice(i, 1);
      }
    }
    
    // --- Update enemies ---
    for (let i = this.enemies.length - 1; i >= 0; i--) {
      const e = this.enemies[i];
      e.timer++;
      
      switch(e.type) {
        case 'fan':
          if(e.formation === 'sine') {
            e.x += e.vx - (this.scrolling ? 0 : 0);
            e.y = e.baseY + Math.sin(e.timer * 0.05 + e.spawnIndex) * 40;
          } else {
            e.x += e.vx;
            e.y = e.baseY + Math.sin(e.timer * 0.06) * 30;
          }
          break;
        case 'rush':
          if(e.timer < 30) {
            // Approach at player Y
            e.y = lerp(e.y, p.y, 0.05);
          }
          e.x += e.vx;
          break;
        case 'ducker':
          if(!e.grounded) { e.x += e.vx; }
          else {
            const terrBot = getTerrainY(sd.terrain.bottom, e.x + this.cameraX);
            e.y = terrBot - 6;
            e.x -= sd.scrollSpeed; // Stay with terrain
          }
          if(e.timer % (e.shootInterval||120) === 0 && p.alive) {
            const a = angleTo(e.x, e.y, p.x, p.y);
            this.enemyBullets.push({
              x: e.x, y: e.y - 6,
              vx: Math.cos(a)*3, vy: Math.sin(a)*3,
              size: 3, color: '#FFAA00'
            });
          }
          break;
        case 'jumper':
          if(e.grounded) {
            const terrBot = getTerrainY(sd.terrain.bottom, e.x + this.cameraX);
            e.y = terrBot - 6;
            e.x -= sd.scrollSpeed;
          }
          e.vy += e.gravity || 0.12;
          e.y += e.vy;
          const jTerrBot = getTerrainY(sd.terrain.bottom, e.x + this.cameraX);
          if(e.y >= jTerrBot - 6) {
            e.y = jTerrBot - 6; e.vy = -4 - Math.random()*2;
            if(p.alive && Math.random()<0.5) {
              const a = angleTo(e.x, e.y, p.x, p.y);
              this.enemyBullets.push({ x:e.x, y:e.y, vx:Math.cos(a)*2.5, vy:Math.sin(a)*2.5, size:2, color:'#44FF44' });
            }
          }
          break;
        case 'garun':
          e.circleAngle += 0.03;
          e.circleCenterX -= 1.5;
          e.x = e.circleCenterX + Math.cos(e.circleAngle) * 25;
          e.y = e.circleCenterY + Math.sin(e.circleAngle) * 25;
          break;
        case 'hatch':
          e.x -= sd.scrollSpeed;
          const htBot = getTerrainY(sd.terrain.bottom, e.x + this.cameraX);
          if(e.formation==='fixed') e.y = htBot - 4;
          e.spawnTimer++;
          if(e.spawnTimer % 180 === 0) {
            for(let j=0;j<2;j++){
              this.enemies.push({
                type:'fan', x:e.x, y:e.y-10,
                hp:1, maxHp:1, vx:-2-Math.random(), vy:rnd(-1,1),
                formationId:null, timer:0, phase:0,
                baseY:e.y-10, spawnIndex:0, active:true,
                formation:'sine', score:100
              });
            }
          }
          break;
        case 'moai':
          e.x -= sd.scrollSpeed;
          e.mouthTimer++;
          e.mouthOpen = Math.sin(e.mouthTimer*0.03) > 0;
          if(e.mouthOpen && e.mouthTimer % 90 === 0) {
            // Ion ring
            this.enemyBullets.push({
              x: e.x-10, y: e.y+4,
              vx: -1.5, vy: rnd(-0.3,0.3),
              size: 8, color:'#AAFFAA', ring:true, ringHp:3
            });
          }
          break;
      }
      
      // Remove off-screen enemies
      if (e.x < -30 || e.x > W + 200 || e.y < -30 || e.y > H + 30) {
        this.enemies.splice(i, 1);
      }
    }
    
    // --- Update bosses ---
    this.bosses.forEach(boss => {
      if (boss.active) this.updateBoss(boss);
    });
    
    // --- Update capsules ---
    for (let i = this.capsules.length - 1; i >= 0; i--) {
      const c = this.capsules[i];
      c.x += c.vx; c.y += c.vy;
      c.timer++;
      if (c.x < -10 || c.x > W+10) { this.capsules.splice(i,1); }
    }
    
    // --- COLLISION DETECTION ---
    if (p.alive) {
      // Player bullets vs enemies
      for (let bi = this.playerBullets.length-1; bi >= 0; bi--) {
        const b = this.playerBullets[bi];
        for (let ei = this.enemies.length-1; ei >= 0; ei--) {
          const e = this.enemies[ei];
          const es = e.type === 'moai' ? 16 : e.type === 'hatch' ? 10 : 7;
          if (aabb(b.x-b.size, b.y-b.size, b.size*2, b.size*2, e.x-es, e.y-es, es*2, es*2)) {
            // Moai: only when mouth open
            if(e.type === 'moai' && !e.mouthOpen) { continue; }
            
            e.hp -= b.damage;
            audio.playSE('enemyHit');
            spawnExplosion(b.x, b.y, 3, 2, 8, 2, ['#FFF','#FF8','#F80']);
            this.playerBullets.splice(bi, 1);
            
            if (e.hp <= 0) {
              this.addScore(e.score || 100);
              audio.playSE('explodeSmall');
              spawnExplosion(e.x, e.y, 10, 3, 15, 3);
              
              // Formation tracking
              if (e.formationId && this.formationKills[e.formationId]) {
                const fk = this.formationKills[e.formationId];
                fk.killed++;
                if (fk.killed >= fk.total && fk.powerUp) {
                  this.capsules.push({
                    x: e.x, y: e.y, vx: -1, vy: 0, timer: 0
                  });
                }
              }
              this.enemies.splice(ei, 1);
            }
            break;
          }
        }
      }
      
      // Laser vs enemies
      if (p.hasLaser && p.laserActive) {
        const laserW = W * CONFIG.LASER_WIDTH_RATIO;
        const laserH = CONFIG.LASER_BEAM_HEIGHT;
        const shootPoints = [{x:p.x, y:p.y}];
        this.options.forEach(o => shootPoints.push({x:o.x, y:o.y}));
        
        shootPoints.forEach(sp => {
          for (let ei = this.enemies.length-1; ei >= 0; ei--) {
            const e = this.enemies[ei];
            const es = e.type === 'moai' ? 16 : e.type === 'hatch' ? 10 : 7;
            if (aabb(sp.x+12, sp.y-laserH/2, laserW, laserH, e.x-es, e.y-es, es*2, es*2)) {
              if(e.type === 'moai' && !e.mouthOpen) continue;
              e.hp--;
              if(e.hp <= 0) {
                this.addScore(e.score || 100);
                audio.playSE('explodeSmall');
                spawnExplosion(e.x, e.y, 10, 3, 15, 3);
                if(e.formationId && this.formationKills[e.formationId]) {
                  const fk = this.formationKills[e.formationId];
                  fk.killed++;
                  if(fk.killed >= fk.total && fk.powerUp) {
                    this.capsules.push({x:e.x, y:e.y, vx:-1, vy:0, timer:0});
                  }
                }
                this.enemies.splice(ei, 1);
              }
            }
          }
          // Laser vs bosses
          this.bosses.forEach(boss => {
            if(!boss.active) return;
            const bs = boss.type === 'zeros_force' ? 20 : boss.type === 'moai_titan' ? 40 : 30;
            if(aabb(sp.x+12, sp.y-laserH/2, laserW, laserH, boss.x-bs, boss.y-bs, bs*2, bs*2)) {
              this.damageBoss(boss, 1);
            }
            // Tentacle damage
            if(boss.tentacles) {
              boss.tentacles.forEach((tent,ti) => {
                if(tent.hp <= 0) return;
                const ta = boss.tentAngle + (Math.PI*2/4)*ti;
                const tx = boss.x + Math.cos(ta)*56;
                const ty = boss.y + Math.sin(ta)*56;
                if(aabb(sp.x+12, sp.y-laserH/2, laserW, laserH, tx-6, ty-6, 12, 12)){
                  tent.hp--;
                  if(tent.hp<=0) spawnExplosion(tx,ty,12,3,20,3);
                }
              });
            }
          });
        });
      }
      
      // Player bullets vs bosses
      for (let bi = this.playerBullets.length-1; bi >= 0; bi--) {
        const b = this.playerBullets[bi];
        for(const boss of this.bosses) {
          if(!boss.active) continue;
          const bs = boss.type === 'zeros_force' ? 20 : boss.type === 'moai_titan' ? 40 : 30;
          if(aabb(b.x-b.size, b.y-b.size, b.size*2, b.size*2, boss.x-bs, boss.y-bs, bs*2, bs*2)) {
            this.damageBoss(boss, b.damage);
            spawnExplosion(b.x, b.y, 3, 2, 8, 2, ['#FFF','#FF8','#F80']);
            this.playerBullets.splice(bi, 1);
            break;
          }
          // Tentacle hits
          if(boss.tentacles) {
            let hit = false;
            boss.tentacles.forEach((tent,ti) => {
              if(tent.hp <= 0 || hit) return;
              const ta = boss.tentAngle + (Math.PI*2/4)*ti;
              const tx = boss.x + Math.cos(ta)*56;
              const ty = boss.y + Math.sin(ta)*56;
              if(aabb(b.x-b.size, b.y-b.size, b.size*2, b.size*2, tx-6, ty-6, 12, 12)){
                tent.hp -= b.damage;
                if(tent.hp<=0) { spawnExplosion(tx,ty,12,3,20,3); audio.playSE('explodeSmall'); }
                spawnExplosion(b.x,b.y,3,2,8,2,['#FFF','#FF8','#F80']);
                this.playerBullets.splice(bi, 1);
                hit = true;
              }
            });
            if(hit) break;
          }
        }
      }
      
      // Player bullets vs ring bullets
      for(let bi = this.playerBullets.length-1; bi>=0; bi--){
        const b = this.playerBullets[bi];
        for(let ei = this.enemyBullets.length-1; ei>=0; ei--){
          const eb = this.enemyBullets[ei];
          if(!eb.ring) continue;
          if(dist(b.x,b.y,eb.x,eb.y) < eb.size + b.size) {
            eb.ringHp--;
            this.playerBullets.splice(bi,1);
            if(eb.ringHp <= 0) { this.enemyBullets.splice(ei,1); }
            break;
          }
        }
      }
      
      // Enemy bullets vs player
      if (p.invTimer <= 0) {
        for (let i = this.enemyBullets.length-1; i >= 0; i--) {
          const b = this.enemyBullets[i];
          const hw = CONFIG.PLAYER_HITBOX_W/2, hh = CONFIG.PLAYER_HITBOX_H/2;
          if (aabb(b.x-b.size, b.y-b.size, b.size*2, b.size*2, p.x-hw, p.y-hh, hw*2, hh*2)) {
            // Shield check
            if (p.shieldHp > 0 && b.x > p.x) {
              p.shieldHp--;
              audio.playSE('shieldHit');
              this.enemyBullets.splice(i, 1);
              continue;
            }
            this.enemyBullets.splice(i, 1);
            this.playerDie();
            break;
          }
        }
      }
      
      // Enemies vs player
      if (p.invTimer <= 0 && p.alive) {
        for (const e of this.enemies) {
          const es = e.type === 'moai' ? 14 : e.type === 'hatch' ? 8 : 6;
          const hw = CONFIG.PLAYER_HITBOX_W/2, hh = CONFIG.PLAYER_HITBOX_H/2;
          if (aabb(e.x-es, e.y-es, es*2, es*2, p.x-hw, p.y-hh, hw*2, hh*2)) {
            if (p.shieldHp > 0) {
              p.shieldHp--;
              audio.playSE('shieldHit');
              continue;
            }
            this.playerDie();
            break;
          }
        }
      }
      
      // Boss vs player
      if(p.invTimer <= 0 && p.alive) {
        this.bosses.forEach(boss => {
          if(!boss.active) return;
          const bs = boss.type === 'zeros_force' ? 18 : boss.type === 'moai_titan' ? 35 : 25;
          const hw = CONFIG.PLAYER_HITBOX_W/2, hh = CONFIG.PLAYER_HITBOX_H/2;
          if(aabb(boss.x-bs, boss.y-bs, bs*2, bs*2, p.x-hw, p.y-hh, hw*2, hh*2)){
            this.playerDie();
          }
        });
      }
      
      // Capsules vs player
      for (let i = this.capsules.length-1; i >= 0; i--) {
        const c = this.capsules[i];
        if (dist(c.x, c.y, p.x, p.y) < 16) {
          this.capsules.splice(i, 1);
          this.powerGauge.cursor = Math.min(this.powerGauge.cursor + 1, 5);
          if (this.powerGauge.cursor < 0) this.powerGauge.cursor = 0;
          audio.playSE('capsule');
        }
      }
    }
    
    // Ambient particles based on stage
    if(this.frame % 3 === 0) {
      if(this.stageNum === 1) {
        spawnParticle(rnd(0,W), H+5, rnd(-0.5,0.5), rnd(-1.5,-0.5), rndInt(40,80), rnd(1,2),
          ['#FFCC00','#FF8800','#FF4400'], -0.02, 0.99);
      } else if(this.stageNum === 3) {
        if(Math.random()<0.3) {
          spawnParticle(W+5, rnd(0,H), rnd(-2,-0.5), rnd(-0.2,0.2), rndInt(30,60), rnd(0.5,1.5),
            ['#44AAFF','#2266AA','#113366'], 0, 0.99);
        }
      }
    }
  }

  // ==================== RENDERING ====================
  render() {
    ctx.save();
    ctx.translate(Math.round(shakeX), Math.round(shakeY));
    
    switch(this.state) {
      case 'title': this.renderTitle(); break;
      case 'warning': this.renderGame(); this.renderWarning(); break;
      case 'playing': this.renderGame(); break;
      case 'paused': this.renderGame(); this.renderPause(); break;
      case 'gameover': this.renderGame(); this.renderGameOver(); break;
      case 'stageclear': this.renderGame(); this.renderStageClear(); break;
      case 'ending': this.renderEnding(); break;
    }
    
    // Flash
    if (this.flashAlpha > 0.01) {
      ctx.fillStyle = `rgba(255,255,255,${this.flashAlpha})`;
      ctx.fillRect(-10, -10, W+20, H+20);
    }
    
    ctx.restore();
    
    // CRT (not affected by shake)
    if (this.crtEnabled) drawCRT(ctx);
    
    // Debug
    if (this.debug) this.renderDebug();
  }

  renderBackground() {
    const sd = this.stageData;
    const c = sd.colors;
    
    // Sky gradient
    const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
    skyGrad.addColorStop(0, c.sky1);
    skyGrad.addColorStop(1, c.sky2);
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, W, H);
    
    // Stars (stages 2 & 3)
    if (this.stageNum >= 2) {
      ctx.fillStyle = '#FFF';
      for (let i = 0; i < 50; i++) {
        const sx = ((i * 73 + 17) % W + this.cameraX * 0.1) % W;
        const sy = (i * 37 + 11) % H;
        const brightness = (Math.sin(this.frame * 0.02 + i) * 0.3 + 0.7);
        ctx.globalAlpha = brightness * 0.6;
        ctx.fillRect(sx, sy, 1, 1);
      }
      ctx.globalAlpha = 1;
    }
    
    // Parallax mountain/structure layer
    ctx.fillStyle = c.rock2 || '#222';
    for (let i = -1; i < 6; i++) {
      const bx = (i * 160 - (this.cameraX * 0.3) % 160);
      const bh = 30 + Math.sin(i * 2.1) * 20;
      if(this.stageNum === 1) {
        // Volcanoes
        ctx.beginPath();
        ctx.moveTo(bx, H);
        ctx.lineTo(bx+40, H-bh-40);
        ctx.lineTo(bx+50, H-bh-50);
        ctx.lineTo(bx+60, H-bh-40);
        ctx.lineTo(bx+100, H);
        ctx.fill();
      } else if(this.stageNum === 2) {
        // Ruins pillars
        ctx.fillRect(bx+20, H-bh-30, 12, bh+30);
        ctx.fillRect(bx+60, H-bh-20, 12, bh+20);
        ctx.fillRect(bx+15, H-bh-35, 65, 6);
      } else {
        // Fortress pipes
        ctx.fillRect(bx, 0, 8, H);
        ctx.fillRect(bx+50, 0, 6, H);
        ctx.fillStyle = '#3A4A5A';
        ctx.fillRect(bx+10, H*0.3, 35, 4);
        ctx.fillRect(bx+10, H*0.6, 35, 4);
        ctx.fillStyle = c.rock2;
      }
    }
    
    // Near parallax layer
    if (this.stageNum === 1) {
      // Lava at bottom
      ctx.fillStyle = '#FF4400';
      const lavaY = H - 15;
      for (let x = 0; x < W; x += 2) {
        const ly = lavaY + Math.sin((x + this.frame * 2) * 0.05) * 3;
        ctx.fillStyle = `rgb(${255},${Math.floor(68+Math.sin((x+this.frame)*0.08)*50)},0)`;
        ctx.fillRect(x, ly, 2, H - ly);
      }
    }
  }

  renderTerrain() {
    const sd = this.stageData;
    const c = sd.colors;
    
    // Top terrain
    ctx.fillStyle = c.rock;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    for (let x = 0; x <= W; x += 4) {
      const wy = getTerrainY(sd.terrain.top, x + this.cameraX);
      ctx.lineTo(x, wy);
    }
    ctx.lineTo(W, 0);
    ctx.closePath();
    ctx.fill();
    
    // Top terrain detail
    ctx.fillStyle = c.rock2 || '#332211';
    ctx.beginPath();
    ctx.moveTo(0, 0);
    for (let x = 0; x <= W; x += 4) {
      const wy = getTerrainY(sd.terrain.top, x + this.cameraX) - 3;
      ctx.lineTo(x, wy);
    }
    ctx.lineTo(W, 0);
    ctx.closePath();
    ctx.fill();
    
    // Bottom terrain
    ctx.fillStyle = c.rock;
    ctx.beginPath();
    ctx.moveTo(0, H);
    for (let x = 0; x <= W; x += 4) {
      const wy = getTerrainY(sd.terrain.bottom, x + this.cameraX);
      ctx.lineTo(x, wy);
    }
    ctx.lineTo(W, H);
    ctx.closePath();
    ctx.fill();
    
    // Bottom terrain detail
    ctx.fillStyle = c.rock2 || '#332211';
    ctx.beginPath();
    ctx.moveTo(0, H);
    for (let x = 0; x <= W; x += 4) {
      const wy = getTerrainY(sd.terrain.bottom, x + this.cameraX) + 3;
      ctx.lineTo(x, wy);
    }
    ctx.lineTo(W, H);
    ctx.closePath();
    ctx.fill();
    
    // Energy lines for stage 3
    if(this.stageNum === 3) {
      ctx.strokeStyle = 'rgba(0,170,255,0.3)';
      ctx.lineWidth = 1;
      for(let x = 0; x < W; x += 60) {
        const wx = x + this.cameraX;
        const topY = getTerrainY(sd.terrain.top, wx);
        const botY = getTerrainY(sd.terrain.bottom, wx);
        if(topY > 5) {
          ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, topY-2); ctx.stroke();
        }
        if(botY < H-5) {
          ctx.beginPath(); ctx.moveTo(x, botY+2); ctx.lineTo(x, H); ctx.stroke();
        }
      }
    }
  }

  renderGame() {
    if (!this.stageData) return;
    
    this.renderBackground();
    this.renderTerrain();
    
    // Enemies
    this.enemies.forEach(e => drawEnemy(ctx, e.type, e.x, e.y, this.frame, e.hp, e.maxHp));
    
    // Enemy bullets
    this.enemyBullets.forEach(b => {
      if(b.ring) {
        ctx.strokeStyle = b.color || '#AAFFAA';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(b.x, b.y, b.size, 0, Math.PI*2); ctx.stroke();
        ctx.fillStyle = `rgba(170,255,170,0.2)`;
        ctx.beginPath(); ctx.arc(b.x, b.y, b.size, 0, Math.PI*2); ctx.fill();
      } else if(b.life !== undefined) {
        ctx.fillStyle = b.color || '#F44';
        ctx.globalAlpha = b.life / 30;
        ctx.fillRect(b.x-b.size, b.y-b.size, b.size*2, b.size*2);
        ctx.globalAlpha = 1;
      } else {
        ctx.fillStyle = b.color || '#F44';
        ctx.beginPath(); ctx.arc(b.x, b.y, b.size, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.beginPath(); ctx.arc(b.x, b.y, b.size*0.5, 0, Math.PI*2); ctx.fill();
      }
    });
    
    // Player bullets
    this.playerBullets.forEach(b => {
      if(b.type === 'missile') {
        ctx.fillStyle = '#FF8800';
        ctx.fillRect(b.x-3, b.y-2, 6, 4);
        ctx.fillStyle = '#FFCC00';
        ctx.fillRect(b.x-1, b.y-1, 2, 2);
        // Trail
        ctx.fillStyle = 'rgba(255,136,0,0.3)';
        ctx.fillRect(b.x-6, b.y-1, 4, 2);
      } else {
        ctx.fillStyle = '#FFF';
        ctx.fillRect(b.x-4, b.y-1, 8, 2);
        ctx.fillStyle = '#AAF';
        ctx.fillRect(b.x-3, b.y, 6, 1);
      }
    });
    
    // Laser
    const p = this.player;
    if (p.alive && p.hasLaser && p.laserActive) {
      const laserW = W * CONFIG.LASER_WIDTH_RATIO;
      const laserH = CONFIG.LASER_BEAM_HEIGHT;
      const shootPoints = [{x:p.x, y:p.y}];
      this.options.forEach(o => shootPoints.push({x:o.x, y:o.y}));
      
      shootPoints.forEach(sp => {
        const grad = ctx.createLinearGradient(sp.x+12, 0, sp.x+12+laserW, 0);
        grad.addColorStop(0, 'rgba(100,200,255,0.9)');
        grad.addColorStop(0.5, 'rgba(150,220,255,0.7)');
        grad.addColorStop(1, 'rgba(100,200,255,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(sp.x+12, sp.y-laserH/2, laserW, laserH);
        // Core
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.fillRect(sp.x+12, sp.y-1, laserW*0.8, 2);
      });
    }
    
    // Capsules
    this.capsules.forEach(c => {
      const pulse = Math.sin(this.frame * 0.15) * 0.3 + 0.7;
      ctx.fillStyle = `rgba(255,136,0,${0.3*pulse})`;
      ctx.beginPath(); ctx.arc(c.x, c.y, 10, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = `rgba(255,170,0,${pulse})`;
      ctx.beginPath(); ctx.arc(c.x, c.y, 6, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#FFF';
      ctx.beginPath(); ctx.arc(c.x-2, c.y-2, 2, 0, Math.PI*2); ctx.fill();
    });
    
    // Options
    this.options.forEach((o, i) => {
      if(i < p.optionCount) drawOption(ctx, o.x, o.y, this.frame);
    });
    
    // Player
    if (p.alive) {
      drawVicViper(ctx, p.x, p.y, this.frame, p.invTimer > 0);
      if (p.shieldHp > 0) drawShield(ctx, p.x, p.y, p.shieldHp, this.frame);
    }
    
    // Bosses
    this.bosses.forEach(boss => {
      if(boss.active || boss.defeated) drawBoss(ctx, boss, this.frame);
    });
    
    // Particles on top
    drawParticles(ctx);
    
    // HUD
    this.renderHUD();
  }

  renderHUD() {
    ctx.font = '8px "Press Start 2P", monospace';
    
    // Top bar
    ctx.fillStyle = '#FFF';
    ctx.textAlign = 'left';
    ctx.fillText('1UP', 8, 12);
    ctx.fillText(String(this.score).padStart(8, '0'), 8, 22);
    
    ctx.textAlign = 'center';
    ctx.fillText('HI', W/2, 12);
    ctx.fillText(String(this.hiScore).padStart(8, '0'), W/2, 22);
    
    ctx.textAlign = 'right';
    ctx.fillStyle = '#FF8';
    ctx.fillText(`STAGE ${this.stageNum}`, W-8, 12);
    
    // Bottom bar - lives
    ctx.textAlign = 'left';
    for (let i = 0; i < this.lives; i++) {
      ctx.fillStyle = '#4488FF';
      ctx.fillRect(8 + i * 14, H - 16, 10, 5);
      ctx.fillStyle = '#88AAFF';
      ctx.fillRect(12 + i * 14, H - 15, 3, 3);
    }
    
    // Power gauge
    const gaugeX = W/2 - 100;
    const gaugeY = H - 18;
    const labels = this.powerGauge.slots;
    
    for (let i = 0; i < 6; i++) {
      const isSelected = i === this.powerGauge.cursor;
      const isActive = this.isPowerUpActive(i);
      
      if (isSelected) {
        ctx.fillStyle = (this.frame % 10 < 5) ? '#FF8800' : '#CC6600';
      } else if (isActive) {
        ctx.fillStyle = '#FFFFFF';
      } else {
        ctx.fillStyle = '#2A1A4A';
      }
      
      ctx.fillRect(gaugeX + i * 34, gaugeY, 30, 12);
      ctx.strokeStyle = '#555';
      ctx.strokeRect(gaugeX + i * 34, gaugeY, 30, 12);
      
      ctx.fillStyle = isSelected ? '#000' : (isActive ? '#000' : '#888');
      ctx.textAlign = 'center';
      ctx.font = '6px "Press Start 2P", monospace';
      ctx.fillText(labels[i], gaugeX + i * 34 + 15, gaugeY + 9);
    }
    
    ctx.font = '8px "Press Start 2P", monospace';
  }

  isPowerUpActive(index) {
    const p = this.player;
    switch(index) {
      case 0: return p.speedLevel > 0;
      case 1: return p.hasMissile;
      case 2: return p.hasDouble;
      case 3: return p.hasLaser;
      case 4: return p.optionCount > 0;
      case 5: return p.shieldHp > 0;
    }
    return false;
  }

  renderTitle() {
    // Space background
    ctx.fillStyle = '#050510';
    ctx.fillRect(0, 0, W, H);
    
    // Stars
    for (let i = 0; i < 80; i++) {
      const sx = ((i * 73 + 17) % W + this.titleFrame * 0.5) % W;
      const sy = (i * 37 + 11) % H;
      const brightness = Math.sin(this.titleFrame * 0.03 + i * 0.5) * 0.3 + 0.7;
      ctx.fillStyle = `rgba(255,255,255,${brightness * 0.7})`;
      ctx.fillRect(W - sx, sy, 1, 1);
    }
    
    // Demo Vic Viper flying across
    const demoX = (W + 40) - ((this.titleFrame * 0.8) % (W + 80));
    const demoY = H * 0.55 + Math.sin(this.titleFrame * 0.02) * 20;
    drawVicViper(ctx, demoX, demoY, this.titleFrame);
    
    // Title logo
    const logoY = H * 0.25;
    
    // Shadow
    ctx.font = '20px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#333';
    ctx.fillText('VIPER', W/2+2, logoY+2);
    ctx.fillText('GENESIS', W/2+2, logoY+28+2);
    
    // Main text with shimmer
    const shimmer = (Math.sin(this.titleFrame * 0.05) * 0.3 + 0.7);
    const grad = ctx.createLinearGradient(W*0.2, 0, W*0.8, 0);
    const shimmerPos = (this.titleFrame * 0.01) % 1;
    grad.addColorStop(Math.max(0, shimmerPos - 0.2), '#AAAAAA');
    grad.addColorStop(shimmerPos, '#FFFFFF');
    grad.addColorStop(Math.min(1, shimmerPos + 0.2), '#AAAAAA');
    ctx.fillStyle = grad;
    ctx.fillText('VIPER', W/2, logoY);
    ctx.fillText('GENESIS', W/2, logoY+28);
    
    // Subtitle
    ctx.font = '6px "Press Start 2P", monospace';
    ctx.fillStyle = '#888';
    ctx.fillText('- A TRIBUTE TO GRADIUS -', W/2, logoY + 46);
    
    // Press start
    if (this.titleFrame % 60 < 40) {
      ctx.font = '8px "Press Start 2P", monospace';
      ctx.fillStyle = '#FFF';
      ctx.fillText('PRESS SPACE TO START', W/2, H * 0.72);
    }
    
    // Controls
    ctx.font = '6px "Press Start 2P", monospace';
    ctx.fillStyle = '#666';
    ctx.fillText('ARROWS:MOVE  Z:SHOT  X:MISSILE  C:POWER UP', W/2, H * 0.85);
    ctx.fillText('ESC:PAUSE  F:FULLSCREEN  GAMEPAD SUPPORTED', W/2, H * 0.92);
  }

  renderWarning() {
    const alpha = Math.sin(this.frame * 0.15) * 0.3 + 0.5;
    ctx.fillStyle = `rgba(0,0,0,0.5)`;
    ctx.fillRect(0, H*0.35, W, H*0.3);
    
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = `rgba(255,255,68,${alpha})`;
    ctx.fillText(`STAGE ${this.stageNum}`, W/2, H*0.47);
    
    const stageNames = ['', 'VOLCANIC INFERNO', 'STONE MONUMENT', 'FORTRESS OF DOOM'];
    ctx.font = '8px "Press Start 2P", monospace';
    ctx.fillStyle = '#FFF';
    ctx.fillText(stageNames[this.stageNum], W/2, H*0.57);
  }

  renderPause() {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, W, H);
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#FFF';
    ctx.fillText('PAUSED', W/2, H/2 - 10);
    ctx.font = '8px "Press Start 2P", monospace';
    ctx.fillStyle = '#AAA';
    ctx.fillText('PRESS ESC TO RESUME', W/2, H/2 + 15);
  }

  renderGameOver() {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, W, H);
    
    // Typewriter effect
    const text = 'GAME OVER';
    const chars = Math.min(Math.floor(this.gameOverTimer / 8), text.length);
    ctx.font = '20px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#FF4444';
    ctx.fillText(text.substring(0, chars), W/2, H/2 - 10);
    
    if (this.gameOverTimer > 60) {
      ctx.font = '8px "Press Start 2P", monospace';
      ctx.fillStyle = '#FFF';
      ctx.fillText(`SCORE: ${String(this.score).padStart(8,'0')}`, W/2, H/2 + 20);
    }
    
    if (this.gameOverTimer > 120) {
      if (this.score >= this.hiScore && this.score > 0) {
        ctx.fillStyle = (this.frame % 20 < 10) ? '#FFD700' : '#FFA500';
        ctx.fillText('NEW HIGH SCORE!', W/2, H/2 + 40);
      }
    }
    
    if (this.gameOverTimer > 180) {
      if (this.frame % 60 < 40) {
        ctx.fillStyle = '#AAA';
        ctx.fillText('PRESS SPACE TO CONTINUE', W/2, H/2 + 60);
      }
    }
  }

  renderStageClear() {
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(0, 0, W, H);
    
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#FFD700';
    ctx.fillText('STAGE CLEAR!', W/2, H/2 - 20);
    
    if (this.stageClearTimer > 30) {
      ctx.font = '8px "Press Start 2P", monospace';
      ctx.fillStyle = '#FFF';
      ctx.fillText(`CLEAR BONUS: ${5000 * this.stageNum}`, W/2, H/2 + 10);
    }
    if (this.stageClearTimer > 60 && this.noMiss) {
      ctx.fillStyle = '#44FF44';
      ctx.fillText('NO MISS BONUS: 10000', W/2, H/2 + 30);
    }
  }

  renderEnding() {
    ctx.fillStyle = '#050510';
    ctx.fillRect(0, 0, W, H);
    
    // Stars
    for (let i = 0; i < 100; i++) {
      const sx = ((i * 73 + 17) % W + this.endingTimer * 0.3) % W;
      const sy = (i * 37 + 11) % H;
      ctx.fillStyle = `rgba(255,255,255,${Math.sin(this.endingTimer*0.02+i)*0.3+0.7})`;
      ctx.fillRect(W - sx, sy, 1, 1);
    }
    
    // Vic Viper flying triumphantly
    const vx = W * 0.3 + Math.sin(this.endingTimer * 0.01) * 30;
    const vy = H * 0.5 + Math.sin(this.endingTimer * 0.02) * 15;
    drawVicViper(ctx, vx, vy, this.endingTimer);
    for(let i=0;i<3;i++){
      drawOption(ctx, vx - 20 - i*15, vy + Math.sin(this.endingTimer*0.03+i)*8, this.endingTimer);
    }
    
    ctx.textAlign = 'center';
    
    if (this.endingTimer > 60) {
      ctx.font = '16px "Press Start 2P", monospace';
      ctx.fillStyle = '#FFD700';
      ctx.fillText('MISSION COMPLETE', W/2, H * 0.2);
    }
    
    if (this.endingTimer > 120) {
      ctx.font = '8px "Press Start 2P", monospace';
      ctx.fillStyle = '#FFF';
      ctx.fillText('CONGRATULATIONS!', W/2, H * 0.3);
    }
    
    if (this.endingTimer > 180) {
      ctx.font = '6px "Press Start 2P", monospace';
      ctx.fillStyle = '#AAA';
      const credits = [
        'VIPER GENESIS',
        '',
        'A TRIBUTE TO GRADIUS',
        'BY KONAMI (1985)',
        '',
        `FINAL SCORE: ${String(this.score).padStart(8,'0')}`,
        '',
        'THANK YOU FOR PLAYING!'
      ];
      credits.forEach((line, i) => {
        const y = H * 0.65 + i * 14 - Math.max(0, this.endingTimer - 200) * 0.3;
        if (y > 0 && y < H) {
          ctx.fillText(line, W/2, y);
        }
      });
    }
    
    if (this.endingTimer > 300 && this.frame % 60 < 40) {
      ctx.font = '8px "Press Start 2P", monospace';
      ctx.fillStyle = '#888';
      ctx.fillText('PRESS SPACE', W/2, H - 20);
    }
  }

  renderDebug() {
    ctx.font = '8px monospace';
    ctx.textAlign = 'left';
    ctx.fillStyle = '#0F0';
    const info = [
      `FPS: ~60 | Frame: ${this.frame}`,
      `Cam: ${Math.floor(this.cameraX)} | Enemies: ${this.enemies.length}`,
      `PBullets: ${this.playerBullets.length} | EBullets: ${this.enemyBullets.length}`,
      `Particles: ${particles.length} | State: ${this.state}`,
      `Player: ${Math.floor(this.player.x)},${Math.floor(this.player.y)}`,
      `Invincible: ${this.invincible}`
    ];
    info.forEach((t, i) => ctx.fillText(t, 4, 35 + i * 10));
    
    // Show hitboxes
    if (this.player.alive) {
      ctx.strokeStyle = '#0F0';
      ctx.strokeRect(
        this.player.x - CONFIG.PLAYER_HITBOX_W/2,
        this.player.y - CONFIG.PLAYER_HITBOX_H/2,
        CONFIG.PLAYER_HITBOX_W, CONFIG.PLAYER_HITBOX_H
      );
    }
  }
}

// ==================== GAME LOOP ====================
const game = new Game();
const TARGET_FPS = 60;
const FRAME_DURATION = 1000 / TARGET_FPS;
let lastTime = 0;
let accumulator = 0;

function gameLoop(currentTime) {
  requestAnimationFrame(gameLoop);
  
  if (lastTime === 0) { lastTime = currentTime; return; }
  
  const deltaTime = Math.min(currentTime - lastTime, 50); // Cap delta
  lastTime = currentTime;
  accumulator += deltaTime;
  
  const input = getInput();
  
  while (accumulator >= FRAME_DURATION) {
    game.update(input);
    accumulator -= FRAME_DURATION;
  }
  
  game.render();
  updatePrevKeys();
}

// Handle audio context resume on user interaction
canvas.addEventListener('click', () => {
  audio.init();
  if (audio.ctx && audio.ctx.state === 'suspended') audio.ctx.resume();
});

requestAnimationFrame(gameLoop);

</script>
</body>
</html>
